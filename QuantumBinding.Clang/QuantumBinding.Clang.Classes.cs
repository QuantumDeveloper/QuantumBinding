// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

namespace QuantumBinding.Clang
{
    using System;
    using System.Runtime.InteropServices;
    using QuantumBinding.Clang.Interop;

    public static class clang
    {
        ///<summary>
        /// Retrieve the character data associated with the given string.
        ///</summary>
        public static string getCString(QuantumBinding.Clang.Interop.CXString @string)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCString(@string);
        }

        ///<summary>
        /// Free the given string.
        ///</summary>
        public static void disposeString(QuantumBinding.Clang.Interop.CXString @string)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeString(@string);
        }

        ///<summary>
        /// Free the given string set.
        ///</summary>
        public static void disposeStringSet(QuantumBinding.Clang.Interop.CXStringSet? set)
        {
            var arg0 = ReferenceEquals(set, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(set.Value);
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeStringSet(arg0);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Create a CXVirtualFileOverlay object. Must be disposed with clang_VirtualFileOverlay_dispose().
        ///</summary>
        public static CXVirtualFileOverlay VirtualFileOverlay_create(uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_create(options);
        }

        ///<summary>
        /// Map an absolute virtual file path to an absolute real one. The virtual path must be canonicalized (not contain "."/"..").
        ///</summary>
        public static CXErrorCode VirtualFileOverlay_addFileMapping(QuantumBinding.Clang.Interop.CXVirtualFileOverlay param0, string virtualPath, string realPath)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_addFileMapping(param0, virtualPath, realPath);
        }

        ///<summary>
        /// Set the case sensitivity for the CXVirtualFileOverlay object. The CXVirtualFileOverlay object is case-sensitive by default, this option can be used to override the default.
        ///</summary>
        public static CXErrorCode VirtualFileOverlay_setCaseSensitivity(QuantumBinding.Clang.Interop.CXVirtualFileOverlay param0, int caseSensitive)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_setCaseSensitivity(param0, caseSensitive);
        }

        ///<summary>
        /// Write out the CXVirtualFileOverlay object to a char buffer.
        ///</summary>
        public static CXErrorCode VirtualFileOverlay_writeToBuffer(QuantumBinding.Clang.Interop.CXVirtualFileOverlay param0, uint options, out System.IntPtr out_buffer_ptr, out uint out_buffer_size)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_writeToBuffer(param0, options, out out_buffer_ptr, out out_buffer_size);
        }

        ///<summary>
        /// free memory allocated by libclang, such as the buffer returned by CXVirtualFileOverlay() or clang_ModuleMapDescriptor_writeToBuffer().
        ///</summary>
        public static void free(ref System.IntPtr buffer)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_free(buffer);
        }

        ///<summary>
        /// Dispose a CXVirtualFileOverlay object.
        ///</summary>
        public static void VirtualFileOverlay_dispose(QuantumBinding.Clang.Interop.CXVirtualFileOverlay param0)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_dispose(param0);
        }

        ///<summary>
        /// Create a CXModuleMapDescriptor object. Must be disposed with clang_ModuleMapDescriptor_dispose().
        ///</summary>
        public static CXModuleMapDescriptor ModuleMapDescriptor_create(uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_create(options);
        }

        ///<summary>
        /// Sets the framework module name that the module.map describes.
        ///</summary>
        public static CXErrorCode ModuleMapDescriptor_setFrameworkModuleName(QuantumBinding.Clang.Interop.CXModuleMapDescriptor param0, string name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_setFrameworkModuleName(param0, name);
        }

        ///<summary>
        /// Sets the umbrealla header name that the module.map describes.
        ///</summary>
        public static CXErrorCode ModuleMapDescriptor_setUmbrellaHeader(QuantumBinding.Clang.Interop.CXModuleMapDescriptor param0, string name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_setUmbrellaHeader(param0, name);
        }

        ///<summary>
        /// Write out the CXModuleMapDescriptor object to a char buffer.
        ///</summary>
        public static CXErrorCode ModuleMapDescriptor_writeToBuffer(QuantumBinding.Clang.Interop.CXModuleMapDescriptor param0, uint options, out System.IntPtr out_buffer_ptr, out uint out_buffer_size)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_writeToBuffer(param0, options, out out_buffer_ptr, out out_buffer_size);
        }

        ///<summary>
        /// Dispose a CXModuleMapDescriptor object.
        ///</summary>
        public static void ModuleMapDescriptor_dispose(QuantumBinding.Clang.Interop.CXModuleMapDescriptor param0)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_dispose(param0);
        }

        ///<summary>
        /// Provides a shared context for creating translation units.
        ///</summary>
        public static CXIndex createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_createIndex(excludeDeclarationsFromPCH, displayDiagnostics);
        }

        ///<summary>
        /// Destroy the given index.
        ///</summary>
        public static void disposeIndex(QuantumBinding.Clang.Interop.CXIndex index)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeIndex(index);
        }

        ///<summary>
        /// Sets general options associated with a CXIndex.
        ///</summary>
        public static void CXIndex_setGlobalOptions(QuantumBinding.Clang.Interop.CXIndex param0, uint options)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_CXIndex_setGlobalOptions(param0, options);
        }

        ///<summary>
        /// Gets the general options associated with a CXIndex.
        ///</summary>
        public static uint CXIndex_getGlobalOptions(QuantumBinding.Clang.Interop.CXIndex param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXIndex_getGlobalOptions(param0);
        }

        ///<summary>
        /// Sets the invocation emission path option in a CXIndex.
        ///</summary>
        public static void CXIndex_setInvocationEmissionPathOption(QuantumBinding.Clang.Interop.CXIndex param0, string Path)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_CXIndex_setInvocationEmissionPathOption(param0, Path);
        }

        ///<summary>
        /// Retrieve the complete file and path name of the given file.
        ///</summary>
        public static CXString getFileName(QuantumBinding.Clang.Interop.CXFile SFile)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileName(SFile);
        }

        ///<summary>
        /// Retrieve the last modification time of the given file.
        ///</summary>
        public static long getFileTime(QuantumBinding.Clang.Interop.CXFile SFile)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileTime(SFile);
        }

        ///<summary>
        /// Retrieve the unique ID for the given file.
        ///</summary>
        public static int getFileUniqueID(QuantumBinding.Clang.Interop.CXFile file, out QuantumBinding.Clang.Interop.CXFileUniqueID outID)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileUniqueID(file, out outID);
        }

        ///<summary>
        /// Determine whether the given header is guarded against multiple inclusions, either with the conventional #ifndef/#define/#endif macro guards or with #pragma once.
        ///</summary>
        public static uint isFileMultipleIncludeGuarded(QuantumBinding.Clang.Interop.CXTranslationUnit tu, QuantumBinding.Clang.Interop.CXFile file)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isFileMultipleIncludeGuarded(tu, file);
        }

        ///<summary>
        /// Retrieve a file handle within the given translation unit.
        ///</summary>
        public static CXFile getFile(QuantumBinding.Clang.Interop.CXTranslationUnit tu, string file_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFile(tu, file_name);
        }

        ///<summary>
        /// Retrieve the buffer associated with the given file.
        ///</summary>
        public static string getFileContents(QuantumBinding.Clang.Interop.CXTranslationUnit tu, QuantumBinding.Clang.Interop.CXFile file, out ulong size)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileContents(tu, file, out size);
        }

        ///<summary>
        /// Returns non-zero if the file1 and file2 point to the same file, or they are both NULL.
        ///</summary>
        public static int File_isEqual(QuantumBinding.Clang.Interop.CXFile file1, QuantumBinding.Clang.Interop.CXFile file2)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_File_isEqual(file1, file2);
        }

        ///<summary>
        /// Returns the real path name of file.
        ///</summary>
        public static CXString File_tryGetRealPathName(QuantumBinding.Clang.Interop.CXFile file)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_File_tryGetRealPathName(file);
        }

        ///<summary>
        /// Determine whether two source locations, which must refer into the same translation unit, refer to exactly the same point in the source code.
        ///</summary>
        public static uint equalLocations(QuantumBinding.Clang.Interop.CXSourceLocation loc1, QuantumBinding.Clang.Interop.CXSourceLocation loc2)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_equalLocations(loc1, loc2);
        }

        ///<summary>
        /// Retrieves the source location associated with a given file/line/column in a particular translation unit.
        ///</summary>
        public static CXSourceLocation getLocation(QuantumBinding.Clang.Interop.CXTranslationUnit tu, QuantumBinding.Clang.Interop.CXFile file, uint line, uint column)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getLocation(tu, file, line, column);
        }

        ///<summary>
        /// Retrieves the source location associated with a given character offset in a particular translation unit.
        ///</summary>
        public static CXSourceLocation getLocationForOffset(QuantumBinding.Clang.Interop.CXTranslationUnit tu, QuantumBinding.Clang.Interop.CXFile file, uint offset)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getLocationForOffset(tu, file, offset);
        }

        ///<summary>
        /// Returns non-zero if the given source location is in a system header.
        ///</summary>
        public static int Location_isInSystemHeader(QuantumBinding.Clang.Interop.CXSourceLocation location)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Location_isInSystemHeader(location);
        }

        ///<summary>
        /// Returns non-zero if the given source location is in the main file of the corresponding translation unit.
        ///</summary>
        public static int Location_isFromMainFile(QuantumBinding.Clang.Interop.CXSourceLocation location)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Location_isFromMainFile(location);
        }

        ///<summary>
        /// Retrieve a source range given the beginning and ending source locations.
        ///</summary>
        public static CXSourceRange getRange(QuantumBinding.Clang.Interop.CXSourceLocation begin, QuantumBinding.Clang.Interop.CXSourceLocation end)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getRange(begin, end);
        }

        ///<summary>
        /// Determine whether two ranges are equivalent.
        ///</summary>
        public static uint equalRanges(QuantumBinding.Clang.Interop.CXSourceRange range1, QuantumBinding.Clang.Interop.CXSourceRange range2)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_equalRanges(range1, range2);
        }

        ///<summary>
        /// Returns non-zero if range is null.
        ///</summary>
        public static int Range_isNull(QuantumBinding.Clang.Interop.CXSourceRange range)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Range_isNull(range);
        }

        ///<summary>
        /// Retrieve the file, line, column, and offset represented by the given source location.
        ///</summary>
        public static void getExpansionLocation(QuantumBinding.Clang.Interop.CXSourceLocation location, out QuantumBinding.Clang.Interop.CXFile file, out uint line, out uint column, out uint offset)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_getExpansionLocation(location, out file, out line, out column, out offset);
        }

        ///<summary>
        /// Retrieve the file, line and column represented by the given source location, as specified in a # line directive.
        ///</summary>
        public static void getPresumedLocation(QuantumBinding.Clang.Interop.CXSourceLocation location, out QuantumBinding.Clang.Interop.CXString filename, out uint line, out uint column)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_getPresumedLocation(location, out filename, out line, out column);
        }

        ///<summary>
        /// Legacy API to retrieve the file, line, column, and offset represented by the given source location.
        ///</summary>
        public static void getInstantiationLocation(QuantumBinding.Clang.Interop.CXSourceLocation location, out QuantumBinding.Clang.Interop.CXFile file, out uint line, out uint column, out uint offset)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_getInstantiationLocation(location, out file, out line, out column, out offset);
        }

        ///<summary>
        /// Retrieve the file, line, column, and offset represented by the given source location.
        ///</summary>
        public static void getSpellingLocation(QuantumBinding.Clang.Interop.CXSourceLocation location, out QuantumBinding.Clang.Interop.CXFile file, out uint line, out uint column, out uint offset)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_getSpellingLocation(location, out file, out line, out column, out offset);
        }

        ///<summary>
        /// Retrieve the file, line, column, and offset represented by the given source location.
        ///</summary>
        public static void getFileLocation(QuantumBinding.Clang.Interop.CXSourceLocation location, out QuantumBinding.Clang.Interop.CXFile file, out uint line, out uint column, out uint offset)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_getFileLocation(location, out file, out line, out column, out offset);
        }

        ///<summary>
        /// Retrieve a source location representing the first character within a source range.
        ///</summary>
        public static CXSourceLocation getRangeStart(QuantumBinding.Clang.Interop.CXSourceRange range)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getRangeStart(range);
        }

        ///<summary>
        /// Retrieve a source location representing the last character within a source range.
        ///</summary>
        public static CXSourceLocation getRangeEnd(QuantumBinding.Clang.Interop.CXSourceRange range)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getRangeEnd(range);
        }

        ///<summary>
        /// Retrieve all ranges that were skipped by the preprocessor.
        ///</summary>
        public static CXSourceRangeList getSkippedRanges(QuantumBinding.Clang.Interop.CXTranslationUnit tu, QuantumBinding.Clang.Interop.CXFile file)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getSkippedRanges(tu, file);
        }

        ///<summary>
        /// Retrieve all ranges from all files that were skipped by the preprocessor.
        ///</summary>
        public static CXSourceRangeList getAllSkippedRanges(QuantumBinding.Clang.Interop.CXTranslationUnit tu)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getAllSkippedRanges(tu);
        }

        ///<summary>
        /// Destroy the given CXSourceRangeList.
        ///</summary>
        public static void disposeSourceRangeList(QuantumBinding.Clang.Interop.CXSourceRangeList? ranges)
        {
            var arg0 = ReferenceEquals(ranges, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(ranges.Value);
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeSourceRangeList(arg0);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Determine the number of diagnostics in a CXDiagnosticSet.
        ///</summary>
        public static uint getNumDiagnosticsInSet(QuantumBinding.Clang.Interop.CXDiagnosticSet Diags)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumDiagnosticsInSet(Diags);
        }

        ///<summary>
        /// Retrieve a diagnostic associated with the given CXDiagnosticSet.
        ///</summary>
        public static CXDiagnostic getDiagnosticInSet(QuantumBinding.Clang.Interop.CXDiagnosticSet Diags, uint Index)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticInSet(Diags, Index);
        }

        ///<summary>
        /// Deserialize a set of diagnostics from a Clang diagnostics bitcode file.
        ///</summary>
        public static CXDiagnosticSet loadDiagnostics(string file, out CXLoadDiag_Error error, out QuantumBinding.Clang.Interop.CXString errorString)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_loadDiagnostics(file, out error, out errorString);
        }

        ///<summary>
        /// Release a CXDiagnosticSet and all of its contained diagnostics.
        ///</summary>
        public static void disposeDiagnosticSet(QuantumBinding.Clang.Interop.CXDiagnosticSet Diags)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeDiagnosticSet(Diags);
        }

        ///<summary>
        /// Retrieve the child diagnostics of a CXDiagnostic.
        ///</summary>
        public static CXDiagnosticSet getChildDiagnostics(QuantumBinding.Clang.Interop.CXDiagnostic D)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getChildDiagnostics(D);
        }

        ///<summary>
        /// Determine the number of diagnostics produced for the given translation unit.
        ///</summary>
        public static uint getNumDiagnostics(QuantumBinding.Clang.Interop.CXTranslationUnit Unit)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumDiagnostics(Unit);
        }

        ///<summary>
        /// Retrieve a diagnostic associated with the given translation unit.
        ///</summary>
        public static CXDiagnostic getDiagnostic(QuantumBinding.Clang.Interop.CXTranslationUnit Unit, uint Index)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnostic(Unit, Index);
        }

        ///<summary>
        /// Retrieve the complete set of diagnostics associated with a translation unit.
        ///</summary>
        public static CXDiagnosticSet getDiagnosticSetFromTU(QuantumBinding.Clang.Interop.CXTranslationUnit Unit)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticSetFromTU(Unit);
        }

        ///<summary>
        /// Destroy a diagnostic.
        ///</summary>
        public static void disposeDiagnostic(QuantumBinding.Clang.Interop.CXDiagnostic Diagnostic)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeDiagnostic(Diagnostic);
        }

        ///<summary>
        /// Format the given diagnostic in a manner that is suitable for display.
        ///</summary>
        public static CXString formatDiagnostic(QuantumBinding.Clang.Interop.CXDiagnostic Diagnostic, uint Options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_formatDiagnostic(Diagnostic, Options);
        }

        ///<summary>
        /// Determine the severity of the given diagnostic.
        ///</summary>
        public static CXDiagnosticSeverity getDiagnosticSeverity(QuantumBinding.Clang.Interop.CXDiagnostic param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticSeverity(param0);
        }

        ///<summary>
        /// Retrieve the source location of the given diagnostic.
        ///</summary>
        public static CXSourceLocation getDiagnosticLocation(QuantumBinding.Clang.Interop.CXDiagnostic param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticLocation(param0);
        }

        ///<summary>
        /// Retrieve the text of the given diagnostic.
        ///</summary>
        public static CXString getDiagnosticSpelling(QuantumBinding.Clang.Interop.CXDiagnostic param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticSpelling(param0);
        }

        ///<summary>
        /// Retrieve the name of the command-line option that enabled this diagnostic.
        ///</summary>
        public static CXString getDiagnosticOption(QuantumBinding.Clang.Interop.CXDiagnostic Diag, QuantumBinding.Clang.Interop.CXString? Disable)
        {
            var arg1 = ReferenceEquals(Disable, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(Disable.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticOption(Diag, arg1);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Retrieve the category number for this diagnostic.
        ///</summary>
        public static uint getDiagnosticCategory(QuantumBinding.Clang.Interop.CXDiagnostic param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticCategory(param0);
        }

        ///<summary>
        /// Retrieve the name of a particular diagnostic category. This is now deprecated. Use clang_getDiagnosticCategoryText() instead.
        ///</summary>
        public static CXString getDiagnosticCategoryName(uint Category)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticCategoryName(Category);
        }

        ///<summary>
        /// Retrieve the diagnostic category text for a given diagnostic.
        ///</summary>
        public static CXString getDiagnosticCategoryText(QuantumBinding.Clang.Interop.CXDiagnostic param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticCategoryText(param0);
        }

        ///<summary>
        /// Determine the number of source ranges associated with the given diagnostic.
        ///</summary>
        public static uint getDiagnosticNumRanges(QuantumBinding.Clang.Interop.CXDiagnostic param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticNumRanges(param0);
        }

        ///<summary>
        /// Retrieve a source range associated with the diagnostic.
        ///</summary>
        public static CXSourceRange getDiagnosticRange(QuantumBinding.Clang.Interop.CXDiagnostic Diagnostic, uint Range)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticRange(Diagnostic, Range);
        }

        ///<summary>
        /// Determine the number of fix-it hints associated with the given diagnostic.
        ///</summary>
        public static uint getDiagnosticNumFixIts(QuantumBinding.Clang.Interop.CXDiagnostic Diagnostic)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticNumFixIts(Diagnostic);
        }

        ///<summary>
        /// Retrieve the replacement information for a given fix-it.
        ///</summary>
        public static CXString getDiagnosticFixIt(QuantumBinding.Clang.Interop.CXDiagnostic Diagnostic, uint FixIt, QuantumBinding.Clang.Interop.CXSourceRange? ReplacementRange)
        {
            var arg1 = ReferenceEquals(ReplacementRange, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(ReplacementRange.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticFixIt(Diagnostic, FixIt, arg1);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Get the original translation unit source file name.
        ///</summary>
        public static CXString getTranslationUnitSpelling(QuantumBinding.Clang.Interop.CXTranslationUnit CTUnit)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTranslationUnitSpelling(CTUnit);
        }

        ///<summary>
        /// Return the CXTranslationUnit for a given source file and the provided command line arguments one would pass to the compiler.
        ///</summary>
        public static CXTranslationUnit createTranslationUnitFromSourceFile(QuantumBinding.Clang.Interop.CXIndex CIdx, string source_filename, int num_clang_command_line_args, in string[] clang_command_line_args, uint num_unsaved_files, QuantumBinding.Clang.Interop.CXUnsavedFile? unsaved_files)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_createTranslationUnitFromSourceFile(CIdx, source_filename, num_clang_command_line_args, clang_command_line_args, num_unsaved_files, arg1);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Same as clang_createTranslationUnit2, but returns the CXTranslationUnit instead of an error code. In case of an error this routine returns a NULL CXTranslationUnit, without further detailed error codes.
        ///</summary>
        public static CXTranslationUnit createTranslationUnit(QuantumBinding.Clang.Interop.CXIndex CIdx, string ast_filename)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_createTranslationUnit(CIdx, ast_filename);
        }

        ///<summary>
        /// Create a translation unit from an AST file ( -emit-ast).
        ///</summary>
        public static CXErrorCode createTranslationUnit2(QuantumBinding.Clang.Interop.CXIndex CIdx, string ast_filename, out QuantumBinding.Clang.Interop.CXTranslationUnit out_TU)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_createTranslationUnit2(CIdx, ast_filename, out out_TU);
        }

        ///<summary>
        /// Same as clang_parseTranslationUnit2, but returns the CXTranslationUnit instead of an error code. In case of an error this routine returns a NULL CXTranslationUnit, without further detailed error codes.
        ///</summary>
        public static CXTranslationUnit parseTranslationUnit(QuantumBinding.Clang.Interop.CXIndex CIdx, string source_filename, in string[] command_line_args, int num_command_line_args, QuantumBinding.Clang.Interop.CXUnsavedFile? unsaved_files, uint num_unsaved_files, uint options)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_parseTranslationUnit(CIdx, source_filename, command_line_args, num_command_line_args, arg1, num_unsaved_files, options);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Parse the given source file and the translation unit corresponding to that file.
        ///</summary>
        public static CXErrorCode parseTranslationUnit2(QuantumBinding.Clang.Interop.CXIndex CIdx, string source_filename, in string[] command_line_args, int num_command_line_args, QuantumBinding.Clang.Interop.CXUnsavedFile[] unsaved_files, uint num_unsaved_files, uint options, out QuantumBinding.Clang.Interop.CXTranslationUnit out_TU)
        {
            QuantumBinding.Clang.Interop.CXUnsavedFile[] arg1 = null;
            arg1 = ReferenceEquals(unsaved_files, null) ? null : new QuantumBinding.Clang.Interop.CXUnsavedFile[unsaved_files.Length];
            if (!ReferenceEquals(unsaved_files, null))
            {
                for (int i = 0; i < unsaved_files.Length; ++i)
                {
                    arg1[i] = unsaved_files[i];
                }
            }
            return QuantumBinding.Clang.Interop.ClangInterop.clang_parseTranslationUnit2(CIdx, source_filename, command_line_args, num_command_line_args, arg1, num_unsaved_files, options, out out_TU);
        }

        ///<summary>
        /// Same as clang_parseTranslationUnit2 but requires a full command line for command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.
        ///</summary>
        public static CXErrorCode parseTranslationUnit2FullArgv(QuantumBinding.Clang.Interop.CXIndex CIdx, string source_filename, in string[] command_line_args, int num_command_line_args, QuantumBinding.Clang.Interop.CXUnsavedFile? unsaved_files, uint num_unsaved_files, uint options, out QuantumBinding.Clang.Interop.CXTranslationUnit out_TU)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_parseTranslationUnit2FullArgv(CIdx, source_filename, command_line_args, num_command_line_args, arg1, num_unsaved_files, options, out out_TU);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Returns the set of flags that is suitable for saving a translation unit.
        ///</summary>
        public static uint defaultSaveOptions(QuantumBinding.Clang.Interop.CXTranslationUnit TU)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultSaveOptions(TU);
        }

        ///<summary>
        /// Saves a translation unit into a serialized representation of that translation unit on disk.
        ///</summary>
        public static int saveTranslationUnit(QuantumBinding.Clang.Interop.CXTranslationUnit TU, string FileName, uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_saveTranslationUnit(TU, FileName, options);
        }

        ///<summary>
        /// Suspend a translation unit in order to free memory associated with it.
        ///</summary>
        public static uint suspendTranslationUnit(QuantumBinding.Clang.Interop.CXTranslationUnit param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_suspendTranslationUnit(param0);
        }

        ///<summary>
        /// Destroy the specified CXTranslationUnit object.
        ///</summary>
        public static void disposeTranslationUnit(QuantumBinding.Clang.Interop.CXTranslationUnit param0)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeTranslationUnit(param0);
        }

        ///<summary>
        /// Returns the set of flags that is suitable for reparsing a translation unit.
        ///</summary>
        public static uint defaultReparseOptions(QuantumBinding.Clang.Interop.CXTranslationUnit TU)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultReparseOptions(TU);
        }

        ///<summary>
        /// Reparse the source files that produced this translation unit.
        ///</summary>
        public static int reparseTranslationUnit(QuantumBinding.Clang.Interop.CXTranslationUnit TU, uint num_unsaved_files, QuantumBinding.Clang.Interop.CXUnsavedFile? unsaved_files, uint options)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_reparseTranslationUnit(TU, num_unsaved_files, arg1, options);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Returns the human-readable null-terminated C string that represents the name of the memory category. This string should never be freed.
        ///</summary>
        public static string getTUResourceUsageName(CXTUResourceUsageKind kind)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTUResourceUsageName(kind);
        }

        ///<summary>
        /// Return the memory usage of a translation unit. This object should be released with clang_disposeCXTUResourceUsage().
        ///</summary>
        public static CXTUResourceUsage getCXTUResourceUsage(QuantumBinding.Clang.Interop.CXTranslationUnit TU)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCXTUResourceUsage(TU);
        }

        public static void disposeCXTUResourceUsage(QuantumBinding.Clang.Interop.CXTUResourceUsage usage)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeCXTUResourceUsage(usage);
        }

        ///<summary>
        /// Get target information for this translation unit.
        ///</summary>
        public static CXTargetInfo getTranslationUnitTargetInfo(QuantumBinding.Clang.Interop.CXTranslationUnit CTUnit)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTranslationUnitTargetInfo(CTUnit);
        }

        ///<summary>
        /// Destroy the CXTargetInfo object.
        ///</summary>
        public static void TargetInfo_dispose(QuantumBinding.Clang.Interop.CXTargetInfo Info)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_TargetInfo_dispose(Info);
        }

        ///<summary>
        /// Get the normalized target triple as a string.
        ///</summary>
        public static CXString TargetInfo_getTriple(QuantumBinding.Clang.Interop.CXTargetInfo Info)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TargetInfo_getTriple(Info);
        }

        ///<summary>
        /// Get the pointer width of the target in bits.
        ///</summary>
        public static int TargetInfo_getPointerWidth(QuantumBinding.Clang.Interop.CXTargetInfo Info)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TargetInfo_getPointerWidth(Info);
        }

        ///<summary>
        /// Retrieve the cursor that represents the given translation unit.
        ///</summary>
        public static CXCursor getTranslationUnitCursor(QuantumBinding.Clang.Interop.CXTranslationUnit param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTranslationUnitCursor(param0);
        }

        ///<summary>
        /// Determine whether two cursors are equivalent.
        ///</summary>
        public static uint equalCursors(QuantumBinding.Clang.Interop.CXCursor param0, QuantumBinding.Clang.Interop.CXCursor param1)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_equalCursors(param0, param1);
        }

        ///<summary>
        /// Returns non-zero if cursor is null.
        ///</summary>
        public static int Cursor_isNull(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isNull(cursor);
        }

        ///<summary>
        /// Compute a hash value for the given cursor.
        ///</summary>
        public static uint hashCursor(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_hashCursor(param0);
        }

        ///<summary>
        /// Retrieve the kind of the given cursor.
        ///</summary>
        public static CXCursorKind getCursorKind(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorKind(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a declaration.
        ///</summary>
        public static uint isDeclaration(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isDeclaration(param0);
        }

        ///<summary>
        /// Determine whether the given declaration is invalid.
        ///</summary>
        public static uint isInvalidDeclaration(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isInvalidDeclaration(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a simple reference.
        ///</summary>
        public static uint isReference(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isReference(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents an expression.
        ///</summary>
        public static uint isExpression(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isExpression(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a statement.
        ///</summary>
        public static uint isStatement(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isStatement(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents an attribute.
        ///</summary>
        public static uint isAttribute(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isAttribute(param0);
        }

        ///<summary>
        /// Determine whether the given cursor has any attributes.
        ///</summary>
        public static uint Cursor_hasAttrs(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_hasAttrs(C);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents an invalid cursor.
        ///</summary>
        public static uint isInvalid(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isInvalid(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a translation unit.
        ///</summary>
        public static uint isTranslationUnit(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isTranslationUnit(param0);
        }

        ///<summary>
        /// * Determine whether the given cursor represents a preprocessing element, such as a preprocessor directive or macro instantiation.
        ///</summary>
        public static uint isPreprocessing(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isPreprocessing(param0);
        }

        ///<summary>
        /// * Determine whether the given cursor represents a currently unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).
        ///</summary>
        public static uint isUnexposed(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isUnexposed(param0);
        }

        ///<summary>
        /// Determine the linkage of the entity referred to by a given cursor.
        ///</summary>
        public static CXLinkageKind getCursorLinkage(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorLinkage(cursor);
        }

        ///<summary>
        /// Describe the visibility of the entity referred to by a cursor.
        ///</summary>
        public static CXVisibilityKind getCursorVisibility(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorVisibility(cursor);
        }

        ///<summary>
        /// Determine the availability of the entity that this cursor refers to, taking the current target platform into account.
        ///</summary>
        public static CXAvailabilityKind getCursorAvailability(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorAvailability(cursor);
        }

        ///<summary>
        /// Determine the availability of the entity that this cursor refers to on any platforms for which availability information is known.
        ///</summary>
        public static int getCursorPlatformAvailability(QuantumBinding.Clang.Interop.CXCursor cursor, int always_deprecated, QuantumBinding.Clang.Interop.CXString? deprecated_message, ref int always_unavailable, QuantumBinding.Clang.Interop.CXString? unavailable_message, QuantumBinding.Clang.Interop.CXPlatformAvailability[] availability, int availability_size)
        {
            var arg1 = ReferenceEquals(deprecated_message, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(deprecated_message.Value);
            var arg2 = ReferenceEquals(unavailable_message, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unavailable_message.Value);
            QuantumBinding.Clang.Interop.CXPlatformAvailability[] arg3 = null;
            arg3 = ReferenceEquals(availability, null) ? null : new QuantumBinding.Clang.Interop.CXPlatformAvailability[availability.Length];
            if (!ReferenceEquals(availability, null))
            {
                for (int i = 0; i < availability.Length; ++i)
                {
                    arg3[i] = availability[i];
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorPlatformAvailability(cursor, always_deprecated, arg1, ref always_unavailable, arg2, arg3, availability_size);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
            return result;
        }

        ///<summary>
        /// Free the memory associated with a CXPlatformAvailability structure.
        ///</summary>
        public static void disposeCXPlatformAvailability(QuantumBinding.Clang.Interop.CXPlatformAvailability? availability)
        {
            var arg0 = ReferenceEquals(availability, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(availability.Value);
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeCXPlatformAvailability(arg0);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Determine the "language" of the entity referred to by a given cursor.
        ///</summary>
        public static CXLanguageKind getCursorLanguage(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorLanguage(cursor);
        }

        ///<summary>
        /// Determine the "thread-local storage (TLS) kind" of the declaration referred to by a cursor.
        ///</summary>
        public static CXTLSKind getCursorTLSKind(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorTLSKind(cursor);
        }

        ///<summary>
        /// Returns the translation unit that a cursor originated from.
        ///</summary>
        public static CXTranslationUnit Cursor_getTranslationUnit(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTranslationUnit(param0);
        }

        ///<summary>
        /// Disposes a CXCursorSet and releases its associated memory.
        ///</summary>
        public static void disposeCXCursorSet(QuantumBinding.Clang.Interop.CXCursorSet cset)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeCXCursorSet(cset);
        }

        ///<summary>
        /// Queries a CXCursorSet to see if it contains a specific CXCursor.
        ///</summary>
        public static uint CXCursorSet_contains(QuantumBinding.Clang.Interop.CXCursorSet cset, QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXCursorSet_contains(cset, cursor);
        }

        ///<summary>
        /// Inserts a CXCursor into a CXCursorSet.
        ///</summary>
        public static uint CXCursorSet_insert(QuantumBinding.Clang.Interop.CXCursorSet cset, QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXCursorSet_insert(cset, cursor);
        }

        ///<summary>
        /// Determine the semantic parent of the given cursor.
        ///</summary>
        public static CXCursor getCursorSemanticParent(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorSemanticParent(cursor);
        }

        ///<summary>
        /// Determine the lexical parent of the given cursor.
        ///</summary>
        public static CXCursor getCursorLexicalParent(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorLexicalParent(cursor);
        }

        ///<summary>
        /// Determine the set of methods that are overridden by the given method.
        ///</summary>
        public static void getOverriddenCursors(QuantumBinding.Clang.Interop.CXCursor cursor, out QuantumBinding.Clang.Interop.CXCursor[] overridden, out uint num_overridden)
        {
            var arg1 = System.IntPtr.Zero;
            QuantumBinding.Clang.Interop.ClangInterop.clang_getOverriddenCursors(cursor, arg1, out num_overridden);
            var _overridden = new QuantumBinding.Clang.Interop.CXCursor[num_overridden];
            MarshalUtils.IntPtrToManagedArray<QuantumBinding.Clang.Interop.CXCursor>(arg1, _overridden);
            Marshal.FreeHGlobal(arg1);
            overridden = new CXCursor[num_overridden];
            for (int i = 0; i< num_overridden; ++i)
            {
                overridden[i] = _overridden[i];
            }
        }

        ///<summary>
        /// Free the set of overridden cursors returned by clang_getOverriddenCursors().
        ///</summary>
        public static void disposeOverriddenCursors(QuantumBinding.Clang.Interop.CXCursor? overridden)
        {
            var arg0 = ReferenceEquals(overridden, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(overridden.Value);
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeOverriddenCursors(arg0);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Retrieve the file that is included by the given inclusion directive cursor.
        ///</summary>
        public static CXFile getIncludedFile(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getIncludedFile(cursor);
        }

        ///<summary>
        /// Map a source location to the cursor that describes the entity at that location in the source code.
        ///</summary>
        public static CXCursor getCursor(QuantumBinding.Clang.Interop.CXTranslationUnit param0, QuantumBinding.Clang.Interop.CXSourceLocation param1)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursor(param0, param1);
        }

        ///<summary>
        /// Retrieve the physical location of the source constructor referenced by the given cursor.
        ///</summary>
        public static CXSourceLocation getCursorLocation(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorLocation(param0);
        }

        ///<summary>
        /// Retrieve the physical extent of the source construct referenced by the given cursor.
        ///</summary>
        public static CXSourceRange getCursorExtent(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorExtent(param0);
        }

        ///<summary>
        /// Retrieve the type of a CXCursor (if any).
        ///</summary>
        public static CXType getCursorType(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorType(C);
        }

        ///<summary>
        /// Pretty-print the underlying type using the rules of the language of the translation unit from which it came.
        ///</summary>
        public static CXString getTypeSpelling(QuantumBinding.Clang.Interop.CXType CT)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTypeSpelling(CT);
        }

        ///<summary>
        /// Retrieve the underlying type of a typedef declaration.
        ///</summary>
        public static CXType getTypedefDeclUnderlyingType(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTypedefDeclUnderlyingType(C);
        }

        ///<summary>
        /// Retrieve the integer type of an enum declaration.
        ///</summary>
        public static CXType getEnumDeclIntegerType(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getEnumDeclIntegerType(C);
        }

        ///<summary>
        /// Retrieve the integer value of an enum constant declaration as a signed long long.
        ///</summary>
        public static long getEnumConstantDeclValue(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getEnumConstantDeclValue(C);
        }

        ///<summary>
        /// Retrieve the integer value of an enum constant declaration as an unsigned long long.
        ///</summary>
        public static ulong getEnumConstantDeclUnsignedValue(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getEnumConstantDeclUnsignedValue(C);
        }

        ///<summary>
        /// Retrieve the bit width of a bit field declaration as an integer.
        ///</summary>
        public static int getFieldDeclBitWidth(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFieldDeclBitWidth(C);
        }

        ///<summary>
        /// Retrieve the number of non-variadic arguments associated with a given cursor.
        ///</summary>
        public static int Cursor_getNumArguments(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getNumArguments(C);
        }

        ///<summary>
        /// Retrieve the argument cursor of a function or method.
        ///</summary>
        public static CXCursor Cursor_getArgument(QuantumBinding.Clang.Interop.CXCursor C, uint i)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getArgument(C, i);
        }

        ///<summary>
        /// Returns the number of template args of a function decl representing a template specialization.
        ///</summary>
        public static int Cursor_getNumTemplateArguments(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getNumTemplateArguments(C);
        }

        ///<summary>
        /// Retrieve the kind of the I'th template argument of the CXCursor C.
        ///</summary>
        public static CXTemplateArgumentKind Cursor_getTemplateArgumentKind(QuantumBinding.Clang.Interop.CXCursor C, uint I)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTemplateArgumentKind(C, I);
        }

        ///<summary>
        /// Retrieve a CXType representing the type of a TemplateArgument of a function decl representing a template specialization.
        ///</summary>
        public static CXType Cursor_getTemplateArgumentType(QuantumBinding.Clang.Interop.CXCursor C, uint I)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTemplateArgumentType(C, I);
        }

        ///<summary>
        /// Retrieve the value of an Integral TemplateArgument (of a function decl representing a template specialization) as a signed long long.
        ///</summary>
        public static long Cursor_getTemplateArgumentValue(QuantumBinding.Clang.Interop.CXCursor C, uint I)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTemplateArgumentValue(C, I);
        }

        ///<summary>
        /// Retrieve the value of an Integral TemplateArgument (of a function decl representing a template specialization) as an unsigned long long.
        ///</summary>
        public static ulong Cursor_getTemplateArgumentUnsignedValue(QuantumBinding.Clang.Interop.CXCursor C, uint I)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTemplateArgumentUnsignedValue(C, I);
        }

        ///<summary>
        /// Determine whether two CXTypes represent the same type.
        ///</summary>
        public static uint equalTypes(QuantumBinding.Clang.Interop.CXType A, QuantumBinding.Clang.Interop.CXType B)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_equalTypes(A, B);
        }

        ///<summary>
        /// Return the canonical type for a CXType.
        ///</summary>
        public static CXType getCanonicalType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCanonicalType(T);
        }

        ///<summary>
        /// Determine whether a CXType has the "const" qualifier set, without looking through typedefs that may have added "const" at a different level.
        ///</summary>
        public static uint isConstQualifiedType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isConstQualifiedType(T);
        }

        ///<summary>
        /// Determine whether a CXCursor that is a macro, is function like.
        ///</summary>
        public static uint Cursor_isMacroFunctionLike(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isMacroFunctionLike(C);
        }

        ///<summary>
        /// Determine whether a CXCursor that is a macro, is a builtin one.
        ///</summary>
        public static uint Cursor_isMacroBuiltin(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isMacroBuiltin(C);
        }

        ///<summary>
        /// Determine whether a CXCursor that is a function declaration, is an inline declaration.
        ///</summary>
        public static uint Cursor_isFunctionInlined(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isFunctionInlined(C);
        }

        ///<summary>
        /// Determine whether a CXType has the "volatile" qualifier set, without looking through typedefs that may have added "volatile" at a different level.
        ///</summary>
        public static uint isVolatileQualifiedType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isVolatileQualifiedType(T);
        }

        ///<summary>
        /// Determine whether a CXType has the "restrict" qualifier set, without looking through typedefs that may have added "restrict" at a different level.
        ///</summary>
        public static uint isRestrictQualifiedType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isRestrictQualifiedType(T);
        }

        ///<summary>
        /// Returns the address space of the given type.
        ///</summary>
        public static uint getAddressSpace(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getAddressSpace(T);
        }

        ///<summary>
        /// Returns the typedef name of the given type.
        ///</summary>
        public static CXString getTypedefName(QuantumBinding.Clang.Interop.CXType CT)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTypedefName(CT);
        }

        ///<summary>
        /// For pointer types, returns the type of the pointee.
        ///</summary>
        public static CXType getPointeeType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getPointeeType(T);
        }

        ///<summary>
        /// Return the cursor for the declaration of the given type.
        ///</summary>
        public static CXCursor getTypeDeclaration(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTypeDeclaration(T);
        }

        ///<summary>
        /// Returns the Objective-C type encoding for the specified declaration.
        ///</summary>
        public static CXString getDeclObjCTypeEncoding(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDeclObjCTypeEncoding(C);
        }

        ///<summary>
        /// Returns the Objective-C type encoding for the specified CXType.
        ///</summary>
        public static CXString Type_getObjCEncoding(QuantumBinding.Clang.Interop.CXType type)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getObjCEncoding(type);
        }

        ///<summary>
        /// Retrieve the spelling of a given CXTypeKind.
        ///</summary>
        public static CXString getTypeKindSpelling(CXTypeKind K)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTypeKindSpelling(K);
        }

        ///<summary>
        /// Retrieve the calling convention associated with a function type.
        ///</summary>
        public static CXCallingConv getFunctionTypeCallingConv(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFunctionTypeCallingConv(T);
        }

        ///<summary>
        /// Retrieve the return type associated with a function type.
        ///</summary>
        public static CXType getResultType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getResultType(T);
        }

        ///<summary>
        /// Retrieve the exception specification type associated with a function type. This is a value of type CXCursor_ExceptionSpecificationKind.
        ///</summary>
        public static int getExceptionSpecificationType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getExceptionSpecificationType(T);
        }

        ///<summary>
        /// Retrieve the number of non-variadic parameters associated with a function type.
        ///</summary>
        public static int getNumArgTypes(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumArgTypes(T);
        }

        ///<summary>
        /// Retrieve the type of a parameter of a function type.
        ///</summary>
        public static CXType getArgType(QuantumBinding.Clang.Interop.CXType T, uint i)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getArgType(T, i);
        }

        ///<summary>
        /// Retrieves the base type of the ObjCObjectType.
        ///</summary>
        public static CXType Type_getObjCObjectBaseType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getObjCObjectBaseType(T);
        }

        ///<summary>
        /// Retrieve the number of protocol references associated with an ObjC object/id.
        ///</summary>
        public static uint Type_getNumObjCProtocolRefs(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNumObjCProtocolRefs(T);
        }

        ///<summary>
        /// Retrieve the decl for a protocol reference for an ObjC object/id.
        ///</summary>
        public static CXCursor Type_getObjCProtocolDecl(QuantumBinding.Clang.Interop.CXType T, uint i)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getObjCProtocolDecl(T, i);
        }

        ///<summary>
        /// Retreive the number of type arguments associated with an ObjC object.
        ///</summary>
        public static uint Type_getNumObjCTypeArgs(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNumObjCTypeArgs(T);
        }

        ///<summary>
        /// Retrieve a type argument associated with an ObjC object.
        ///</summary>
        public static CXType Type_getObjCTypeArg(QuantumBinding.Clang.Interop.CXType T, uint i)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getObjCTypeArg(T, i);
        }

        ///<summary>
        /// Return 1 if the CXType is a variadic function type, and 0 otherwise.
        ///</summary>
        public static uint isFunctionTypeVariadic(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isFunctionTypeVariadic(T);
        }

        ///<summary>
        /// Retrieve the return type associated with a given cursor.
        ///</summary>
        public static CXType getCursorResultType(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorResultType(C);
        }

        ///<summary>
        /// Retrieve the exception specification type associated with a given cursor. This is a value of type CXCursor_ExceptionSpecificationKind.
        ///</summary>
        public static int getCursorExceptionSpecificationType(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorExceptionSpecificationType(C);
        }

        ///<summary>
        /// Return 1 if the CXType is a POD (plain old data) type, and 0 otherwise.
        ///</summary>
        public static uint isPODType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isPODType(T);
        }

        ///<summary>
        /// Return the element type of an array, complex, or vector type.
        ///</summary>
        public static CXType getElementType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getElementType(T);
        }

        ///<summary>
        /// Return the number of elements of an array or vector type.
        ///</summary>
        public static long getNumElements(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumElements(T);
        }

        ///<summary>
        /// Return the element type of an array type.
        ///</summary>
        public static CXType getArrayElementType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getArrayElementType(T);
        }

        ///<summary>
        /// Return the array size of a constant array.
        ///</summary>
        public static long getArraySize(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getArraySize(T);
        }

        ///<summary>
        /// Retrieve the type named by the qualified-id.
        ///</summary>
        public static CXType Type_getNamedType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNamedType(T);
        }

        ///<summary>
        /// Determine if a typedef is 'transparent' tag.
        ///</summary>
        public static uint Type_isTransparentTagTypedef(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_isTransparentTagTypedef(T);
        }

        ///<summary>
        /// Retrieve the nullability kind of a pointer type.
        ///</summary>
        public static CXTypeNullabilityKind Type_getNullability(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNullability(T);
        }

        ///<summary>
        /// Return the alignment of a type in bytes as per C++[expr.alignof] standard.
        ///</summary>
        public static long Type_getAlignOf(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getAlignOf(T);
        }

        ///<summary>
        /// Return the class type of an member pointer type.
        ///</summary>
        public static CXType Type_getClassType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getClassType(T);
        }

        ///<summary>
        /// Return the size of a type in bytes as per C++[expr.sizeof] standard.
        ///</summary>
        public static long Type_getSizeOf(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getSizeOf(T);
        }

        ///<summary>
        /// Return the offset of a field named S in a record of type T in bits as it would be returned by __offsetof__ as per C++11[18.2p4]
        ///</summary>
        public static long Type_getOffsetOf(QuantumBinding.Clang.Interop.CXType T, string S)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getOffsetOf(T, S);
        }

        ///<summary>
        /// Return the type that was modified by this attributed type.
        ///</summary>
        public static CXType Type_getModifiedType(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getModifiedType(T);
        }

        ///<summary>
        /// Return the offset of the field represented by the Cursor.
        ///</summary>
        public static long Cursor_getOffsetOfField(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getOffsetOfField(C);
        }

        ///<summary>
        /// Determine whether the given cursor represents an anonymous record declaration.
        ///</summary>
        public static uint Cursor_isAnonymous(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isAnonymous(C);
        }

        ///<summary>
        /// Returns the number of template arguments for given template specialization, or -1 if type T is not a template specialization.
        ///</summary>
        public static int Type_getNumTemplateArguments(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNumTemplateArguments(T);
        }

        ///<summary>
        /// Returns the type template argument of a template class specialization at given index.
        ///</summary>
        public static CXType Type_getTemplateArgumentAsType(QuantumBinding.Clang.Interop.CXType T, uint i)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getTemplateArgumentAsType(T, i);
        }

        ///<summary>
        /// Retrieve the ref-qualifier kind of a function or method.
        ///</summary>
        public static CXRefQualifierKind Type_getCXXRefQualifier(QuantumBinding.Clang.Interop.CXType T)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getCXXRefQualifier(T);
        }

        ///<summary>
        /// Returns non-zero if the cursor specifies a Record member that is a bitfield.
        ///</summary>
        public static uint Cursor_isBitField(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isBitField(C);
        }

        ///<summary>
        /// Returns 1 if the base class specified by the cursor with kind CX_CXXBaseSpecifier is virtual.
        ///</summary>
        public static uint isVirtualBase(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isVirtualBase(param0);
        }

        ///<summary>
        /// Returns the access control level for the referenced object.
        ///</summary>
        public static CX_CXXAccessSpecifier getCXXAccessSpecifier(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCXXAccessSpecifier(param0);
        }

        ///<summary>
        /// Returns the storage class for a function or variable declaration.
        ///</summary>
        public static CX_StorageClass Cursor_getStorageClass(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getStorageClass(param0);
        }

        ///<summary>
        /// Determine the number of overloaded declarations referenced by a CXCursor_OverloadedDeclRef cursor.
        ///</summary>
        public static uint getNumOverloadedDecls(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumOverloadedDecls(cursor);
        }

        ///<summary>
        /// Retrieve a cursor for one of the overloaded declarations referenced by a CXCursor_OverloadedDeclRef cursor.
        ///</summary>
        public static CXCursor getOverloadedDecl(QuantumBinding.Clang.Interop.CXCursor cursor, uint index)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getOverloadedDecl(cursor, index);
        }

        ///<summary>
        /// For cursors representing an iboutletcollection attribute, this function returns the collection element type.
        ///</summary>
        public static CXType getIBOutletCollectionType(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getIBOutletCollectionType(param0);
        }

        ///<summary>
        /// Visit the children of a particular cursor.
        ///</summary>
        public static uint visitChildren(QuantumBinding.Clang.Interop.CXCursor parent, CXCursorVisitor visitor, QuantumBinding.Clang.Interop.CXClientData client_data)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_visitChildren(parent, visitor, client_data);
        }

        ///<summary>
        /// Retrieve a Unified Symbol Resolution (USR) for the entity referenced by the given cursor.
        ///</summary>
        public static CXString getCursorUSR(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorUSR(param0);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C class.
        ///</summary>
        public static CXString constructUSR_ObjCClass(string class_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCClass(class_name);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C category.
        ///</summary>
        public static CXString constructUSR_ObjCCategory(string class_name, string category_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCCategory(class_name, category_name);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C protocol.
        ///</summary>
        public static CXString constructUSR_ObjCProtocol(string protocol_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCProtocol(protocol_name);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C instance variable and the USR for its containing class.
        ///</summary>
        public static CXString constructUSR_ObjCIvar(string name, QuantumBinding.Clang.Interop.CXString classUSR)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCIvar(name, classUSR);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C method and the USR for its containing class.
        ///</summary>
        public static CXString constructUSR_ObjCMethod(string name, uint isInstanceMethod, QuantumBinding.Clang.Interop.CXString classUSR)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCMethod(name, isInstanceMethod, classUSR);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C property and the USR for its containing class.
        ///</summary>
        public static CXString constructUSR_ObjCProperty(string property, QuantumBinding.Clang.Interop.CXString classUSR)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCProperty(property, classUSR);
        }

        ///<summary>
        /// Retrieve a name for the entity referenced by this cursor.
        ///</summary>
        public static CXString getCursorSpelling(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorSpelling(param0);
        }

        ///<summary>
        /// Retrieve a range for a piece that forms the cursors spelling name. Most of the times there is only one range for the complete spelling but for Objective-C methods and Objective-C message expressions, there are multiple pieces for each selector identifier.
        ///</summary>
        public static CXSourceRange Cursor_getSpellingNameRange(QuantumBinding.Clang.Interop.CXCursor param0, uint pieceIndex, uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getSpellingNameRange(param0, pieceIndex, options);
        }

        ///<summary>
        /// Get a property value for the given printing policy.
        ///</summary>
        public static uint PrintingPolicy_getProperty(QuantumBinding.Clang.Interop.CXPrintingPolicy Policy, CXPrintingPolicyProperty Property)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_PrintingPolicy_getProperty(Policy, Property);
        }

        ///<summary>
        /// Set a property value for the given printing policy.
        ///</summary>
        public static void PrintingPolicy_setProperty(QuantumBinding.Clang.Interop.CXPrintingPolicy Policy, CXPrintingPolicyProperty Property, uint Value)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_PrintingPolicy_setProperty(Policy, Property, Value);
        }

        ///<summary>
        /// Retrieve the default policy for the cursor.
        ///</summary>
        public static CXPrintingPolicy getCursorPrintingPolicy(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorPrintingPolicy(param0);
        }

        ///<summary>
        /// Release a printing policy.
        ///</summary>
        public static void PrintingPolicy_dispose(QuantumBinding.Clang.Interop.CXPrintingPolicy Policy)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_PrintingPolicy_dispose(Policy);
        }

        ///<summary>
        /// Pretty print declarations.
        ///</summary>
        public static CXString getCursorPrettyPrinted(QuantumBinding.Clang.Interop.CXCursor Cursor, QuantumBinding.Clang.Interop.CXPrintingPolicy Policy)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorPrettyPrinted(Cursor, Policy);
        }

        ///<summary>
        /// Retrieve the display name for the entity referenced by this cursor.
        ///</summary>
        public static CXString getCursorDisplayName(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorDisplayName(param0);
        }

        ///<summary>
        /// For a cursor that is a reference, retrieve a cursor representing the entity that it references.
        ///</summary>
        public static CXCursor getCursorReferenced(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorReferenced(param0);
        }

        ///<summary>
        /// For a cursor that is either a reference to or a declaration of some entity, retrieve a cursor that describes the definition of that entity.
        ///</summary>
        public static CXCursor getCursorDefinition(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorDefinition(param0);
        }

        ///<summary>
        /// Determine whether the declaration pointed to by this cursor is also a definition of that entity.
        ///</summary>
        public static uint isCursorDefinition(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isCursorDefinition(param0);
        }

        ///<summary>
        /// Retrieve the canonical cursor corresponding to the given cursor.
        ///</summary>
        public static CXCursor getCanonicalCursor(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCanonicalCursor(param0);
        }

        ///<summary>
        /// If the cursor points to a selector identifier in an Objective-C method or message expression, this returns the selector index.
        ///</summary>
        public static int Cursor_getObjCSelectorIndex(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCSelectorIndex(param0);
        }

        ///<summary>
        /// Given a cursor pointing to a C++ method call or an Objective-C message, returns non-zero if the method/message is "dynamic", meaning:
        ///</summary>
        public static int Cursor_isDynamicCall(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isDynamicCall(C);
        }

        ///<summary>
        /// Given a cursor pointing to an Objective-C message or property reference, or C++ method call, returns the CXType of the receiver.
        ///</summary>
        public static CXType Cursor_getReceiverType(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getReceiverType(C);
        }

        ///<summary>
        /// Given a cursor that represents a property declaration, return the associated property attributes. The bits are formed from CXObjCPropertyAttrKind.
        ///</summary>
        public static uint Cursor_getObjCPropertyAttributes(QuantumBinding.Clang.Interop.CXCursor C, uint reserved)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCPropertyAttributes(C, reserved);
        }

        ///<summary>
        /// Given a cursor that represents a property declaration, return the name of the method that implements the getter.
        ///</summary>
        public static CXString Cursor_getObjCPropertyGetterName(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCPropertyGetterName(C);
        }

        ///<summary>
        /// Given a cursor that represents a property declaration, return the name of the method that implements the setter, if any.
        ///</summary>
        public static CXString Cursor_getObjCPropertySetterName(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCPropertySetterName(C);
        }

        ///<summary>
        /// Given a cursor that represents an Objective-C method or parameter declaration, return the associated Objective-C qualifiers for the return type or the parameter respectively. The bits are formed from CXObjCDeclQualifierKind.
        ///</summary>
        public static uint Cursor_getObjCDeclQualifiers(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCDeclQualifiers(C);
        }

        ///<summary>
        /// Given a cursor that represents an Objective-C method or property declaration, return non-zero if the declaration was affected by "@optional". Returns zero if the cursor is not such a declaration or it is "@required".
        ///</summary>
        public static uint Cursor_isObjCOptional(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isObjCOptional(C);
        }

        ///<summary>
        /// Returns non-zero if the given cursor is a variadic function or method.
        ///</summary>
        public static uint Cursor_isVariadic(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isVariadic(C);
        }

        ///<summary>
        /// Returns non-zero if the given cursor points to a symbol marked with external_source_symbol attribute.
        ///</summary>
        public static uint Cursor_isExternalSymbol(QuantumBinding.Clang.Interop.CXCursor C, QuantumBinding.Clang.Interop.CXString? language, QuantumBinding.Clang.Interop.CXString? definedIn, ref uint isGenerated)
        {
            var arg1 = ReferenceEquals(language, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(language.Value);
            var arg2 = ReferenceEquals(definedIn, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(definedIn.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isExternalSymbol(C, arg1, arg2, ref isGenerated);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents a declaration, return the associated comment's source range. The range may include multiple consecutive comments with whitespace in between.
        ///</summary>
        public static CXSourceRange Cursor_getCommentRange(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getCommentRange(C);
        }

        ///<summary>
        /// Given a cursor that represents a declaration, return the associated comment text, including comment markers.
        ///</summary>
        public static CXString Cursor_getRawCommentText(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getRawCommentText(C);
        }

        ///<summary>
        /// Given a cursor that represents a documentable entity (e.g., declaration), return the associated first paragraph.
        ///</summary>
        public static CXString Cursor_getBriefCommentText(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getBriefCommentText(C);
        }

        ///<summary>
        /// Retrieve the CXString representing the mangled name of the cursor.
        ///</summary>
        public static CXString Cursor_getMangling(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getMangling(param0);
        }

        ///<summary>
        /// Retrieve the CXStrings representing the mangled symbols of the C++ constructor or destructor at the cursor.
        ///</summary>
        public static CXStringSet Cursor_getCXXManglings(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getCXXManglings(param0);
        }

        ///<summary>
        /// Retrieve the CXStrings representing the mangled symbols of the ObjC class interface or implementation at the cursor.
        ///</summary>
        public static CXStringSet Cursor_getObjCManglings(QuantumBinding.Clang.Interop.CXCursor param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCManglings(param0);
        }

        ///<summary>
        /// Given a CXCursor_ModuleImportDecl cursor, return the associated module.
        ///</summary>
        public static CXModule Cursor_getModule(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getModule(C);
        }

        ///<summary>
        /// Given a CXFile header file, return the module that contains it, if one exists.
        ///</summary>
        public static CXModule getModuleForFile(QuantumBinding.Clang.Interop.CXTranslationUnit param0, QuantumBinding.Clang.Interop.CXFile param1)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getModuleForFile(param0, param1);
        }

        ///<summary>
        /// Returns the module file where the provided module object came from.
        ///</summary>
        public static CXFile Module_getASTFile(QuantumBinding.Clang.Interop.CXModule Module)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getASTFile(Module);
        }

        ///<summary>
        /// Returns the parent of a sub-module or NULL if the given module is top-level, e.g. for 'std.vector' it will return the 'std' module.
        ///</summary>
        public static CXModule Module_getParent(QuantumBinding.Clang.Interop.CXModule Module)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getParent(Module);
        }

        ///<summary>
        /// Returns the name of the module, e.g. for the 'std.vector' sub-module it will return "vector".
        ///</summary>
        public static CXString Module_getName(QuantumBinding.Clang.Interop.CXModule Module)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getName(Module);
        }

        ///<summary>
        /// Returns the full name of the module, e.g. "std.vector".
        ///</summary>
        public static CXString Module_getFullName(QuantumBinding.Clang.Interop.CXModule Module)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getFullName(Module);
        }

        ///<summary>
        /// Returns non-zero if the module is a system one.
        ///</summary>
        public static int Module_isSystem(QuantumBinding.Clang.Interop.CXModule Module)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_isSystem(Module);
        }

        ///<summary>
        /// Returns the number of top level headers associated with this module.
        ///</summary>
        public static uint Module_getNumTopLevelHeaders(QuantumBinding.Clang.Interop.CXTranslationUnit param0, QuantumBinding.Clang.Interop.CXModule Module)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getNumTopLevelHeaders(param0, Module);
        }

        ///<summary>
        /// Returns the specified top level header associated with the module.
        ///</summary>
        public static CXFile Module_getTopLevelHeader(QuantumBinding.Clang.Interop.CXTranslationUnit param0, QuantumBinding.Clang.Interop.CXModule Module, uint Index)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getTopLevelHeader(param0, Module, Index);
        }

        ///<summary>
        /// Determine if a C++ constructor is a converting constructor.
        ///</summary>
        public static uint CXXConstructor_isConvertingConstructor(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXConstructor_isConvertingConstructor(C);
        }

        ///<summary>
        /// Determine if a C++ constructor is a copy constructor.
        ///</summary>
        public static uint CXXConstructor_isCopyConstructor(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXConstructor_isCopyConstructor(C);
        }

        ///<summary>
        /// Determine if a C++ constructor is the default constructor.
        ///</summary>
        public static uint CXXConstructor_isDefaultConstructor(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXConstructor_isDefaultConstructor(C);
        }

        ///<summary>
        /// Determine if a C++ constructor is a move constructor.
        ///</summary>
        public static uint CXXConstructor_isMoveConstructor(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXConstructor_isMoveConstructor(C);
        }

        ///<summary>
        /// Determine if a C++ field is declared 'mutable'.
        ///</summary>
        public static uint CXXField_isMutable(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXField_isMutable(C);
        }

        ///<summary>
        /// Determine if a C++ method is declared '= default'.
        ///</summary>
        public static uint CXXMethod_isDefaulted(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isDefaulted(C);
        }

        ///<summary>
        /// Determine if a C++ member function or member function template is pure virtual.
        ///</summary>
        public static uint CXXMethod_isPureVirtual(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isPureVirtual(C);
        }

        ///<summary>
        /// Determine if a C++ member function or member function template is declared 'static'.
        ///</summary>
        public static uint CXXMethod_isStatic(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isStatic(C);
        }

        ///<summary>
        /// Determine if a C++ member function or member function template is explicitly declared 'virtual' or if it overrides a virtual method from one of the base classes.
        ///</summary>
        public static uint CXXMethod_isVirtual(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isVirtual(C);
        }

        ///<summary>
        /// Determine if a C++ record is abstract, i.e. whether a class or struct has a pure virtual member function.
        ///</summary>
        public static uint CXXRecord_isAbstract(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXRecord_isAbstract(C);
        }

        ///<summary>
        /// Determine if an enum declaration refers to a scoped enum.
        ///</summary>
        public static uint EnumDecl_isScoped(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EnumDecl_isScoped(C);
        }

        ///<summary>
        /// Determine if a C++ member function or member function template is declared 'const'.
        ///</summary>
        public static uint CXXMethod_isConst(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isConst(C);
        }

        ///<summary>
        /// Given a cursor that represents a template, determine the cursor kind of the specializations would be generated by instantiating the template.
        ///</summary>
        public static CXCursorKind getTemplateCursorKind(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTemplateCursorKind(C);
        }

        ///<summary>
        /// Given a cursor that may represent a specialization or instantiation of a template, retrieve the cursor that represents the template that it specializes or from which it was instantiated.
        ///</summary>
        public static CXCursor getSpecializedCursorTemplate(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getSpecializedCursorTemplate(C);
        }

        ///<summary>
        /// Given a cursor that references something else, return the source range covering that reference.
        ///</summary>
        public static CXSourceRange getCursorReferenceNameRange(QuantumBinding.Clang.Interop.CXCursor C, uint NameFlags, uint PieceIndex)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorReferenceNameRange(C, NameFlags, PieceIndex);
        }

        ///<summary>
        /// Get the raw lexical token starting with the given location.
        ///</summary>
        public static CXToken getToken(QuantumBinding.Clang.Interop.CXTranslationUnit TU, QuantumBinding.Clang.Interop.CXSourceLocation Location)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getToken(TU, Location);
        }

        ///<summary>
        /// Determine the kind of the given token.
        ///</summary>
        public static CXTokenKind getTokenKind(QuantumBinding.Clang.Interop.CXToken param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenKind(param0);
        }

        ///<summary>
        /// Determine the spelling of the given token.
        ///</summary>
        public static CXString getTokenSpelling(QuantumBinding.Clang.Interop.CXTranslationUnit param0, QuantumBinding.Clang.Interop.CXToken param1)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenSpelling(param0, param1);
        }

        ///<summary>
        /// Retrieve the source location of the given token.
        ///</summary>
        public static CXSourceLocation getTokenLocation(QuantumBinding.Clang.Interop.CXTranslationUnit param0, QuantumBinding.Clang.Interop.CXToken param1)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenLocation(param0, param1);
        }

        ///<summary>
        /// Retrieve a source range that covers the given token.
        ///</summary>
        public static CXSourceRange getTokenExtent(QuantumBinding.Clang.Interop.CXTranslationUnit param0, QuantumBinding.Clang.Interop.CXToken param1)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenExtent(param0, param1);
        }

        ///<summary>
        /// Tokenize the source code described by the given range into raw lexical tokens.
        ///</summary>
        public static void tokenize(QuantumBinding.Clang.Interop.CXTranslationUnit TU, QuantumBinding.Clang.Interop.CXSourceRange Range, out QuantumBinding.Clang.Interop.CXToken[] Tokens, out uint NumTokens)
        {
            var arg2 = System.IntPtr.Zero;
            QuantumBinding.Clang.Interop.ClangInterop.clang_tokenize(TU, Range, arg2, out NumTokens);
            var _Tokens = new QuantumBinding.Clang.Interop.CXToken[NumTokens];
            MarshalUtils.IntPtrToManagedArray<QuantumBinding.Clang.Interop.CXToken>(arg2, _Tokens);
            Marshal.FreeHGlobal(arg2);
            Tokens = new CXToken[NumTokens];
            for (int i = 0; i< NumTokens; ++i)
            {
                Tokens[i] = _Tokens[i];
            }
        }

        ///<summary>
        /// Annotate the given set of tokens by providing cursors for each token that can be mapped to a specific entity within the abstract syntax tree.
        ///</summary>
        public static void annotateTokens(QuantumBinding.Clang.Interop.CXTranslationUnit TU, QuantumBinding.Clang.Interop.CXToken[] Tokens, uint NumTokens, out QuantumBinding.Clang.Interop.CXCursor[] Cursors)
        {
            QuantumBinding.Clang.Interop.CXToken[] arg1 = null;
            arg1 = ReferenceEquals(Tokens, null) ? null : new QuantumBinding.Clang.Interop.CXToken[Tokens.Length];
            if (!ReferenceEquals(Tokens, null))
            {
                for (int i = 0; i < Tokens.Length; ++i)
                {
                    arg1[i] = Tokens[i];
                }
            }
            var arg2 = System.IntPtr.Zero;
            QuantumBinding.Clang.Interop.ClangInterop.clang_annotateTokens(TU, arg1, NumTokens, arg2);
            var _Cursors = new QuantumBinding.Clang.Interop.CXCursor[NumTokens];
            MarshalUtils.IntPtrToManagedArray<QuantumBinding.Clang.Interop.CXCursor>(arg2, _Cursors);
            Marshal.FreeHGlobal(arg2);
            Cursors = new CXCursor[NumTokens];
            for (int i = 0; i< NumTokens; ++i)
            {
                Cursors[i] = _Cursors[i];
            }
        }

        ///<summary>
        /// Free the given set of tokens.
        ///</summary>
        public static void disposeTokens(QuantumBinding.Clang.Interop.CXTranslationUnit TU, System.IntPtr Tokens, uint NumTokens)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeTokens(TU, Tokens, NumTokens);
        }

        ///<summary>
        /// for debug/testing
        ///</summary>
        public static CXString getCursorKindSpelling(CXCursorKind Kind)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorKindSpelling(Kind);
        }

        public static void getDefinitionSpellingAndExtent(QuantumBinding.Clang.Interop.CXCursor param0, in string[] startBuf, in string[] endBuf, ref uint startLine, ref uint startColumn, ref uint endLine, ref uint endColumn)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_getDefinitionSpellingAndExtent(param0, startBuf, endBuf, ref startLine, ref startColumn, ref endLine, ref endColumn);
        }

        public static void executeOnThread(System.IntPtr fn, ref System.IntPtr user_data, uint stack_size)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_executeOnThread(fn, user_data, stack_size);
        }

        ///<summary>
        /// Determine the kind of a particular chunk within a completion string.
        ///</summary>
        public static CXCompletionChunkKind getCompletionChunkKind(QuantumBinding.Clang.Interop.CXCompletionString completion_string, uint chunk_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionChunkKind(completion_string, chunk_number);
        }

        ///<summary>
        /// Retrieve the text associated with a particular chunk within a completion string.
        ///</summary>
        public static CXString getCompletionChunkText(QuantumBinding.Clang.Interop.CXCompletionString completion_string, uint chunk_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionChunkText(completion_string, chunk_number);
        }

        ///<summary>
        /// Retrieve the completion string associated with a particular chunk within a completion string.
        ///</summary>
        public static CXCompletionString getCompletionChunkCompletionString(QuantumBinding.Clang.Interop.CXCompletionString completion_string, uint chunk_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionChunkCompletionString(completion_string, chunk_number);
        }

        ///<summary>
        /// Retrieve the number of chunks in the given code-completion string.
        ///</summary>
        public static uint getNumCompletionChunks(QuantumBinding.Clang.Interop.CXCompletionString completion_string)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumCompletionChunks(completion_string);
        }

        ///<summary>
        /// Determine the priority of this code completion.
        ///</summary>
        public static uint getCompletionPriority(QuantumBinding.Clang.Interop.CXCompletionString completion_string)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionPriority(completion_string);
        }

        ///<summary>
        /// Determine the availability of the entity that this code-completion string refers to.
        ///</summary>
        public static CXAvailabilityKind getCompletionAvailability(QuantumBinding.Clang.Interop.CXCompletionString completion_string)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionAvailability(completion_string);
        }

        ///<summary>
        /// Retrieve the number of annotations associated with the given completion string.
        ///</summary>
        public static uint getCompletionNumAnnotations(QuantumBinding.Clang.Interop.CXCompletionString completion_string)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionNumAnnotations(completion_string);
        }

        ///<summary>
        /// Retrieve the annotation associated with the given completion string.
        ///</summary>
        public static CXString getCompletionAnnotation(QuantumBinding.Clang.Interop.CXCompletionString completion_string, uint annotation_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionAnnotation(completion_string, annotation_number);
        }

        ///<summary>
        /// Retrieve the parent context of the given completion string.
        ///</summary>
        public static CXString getCompletionParent(QuantumBinding.Clang.Interop.CXCompletionString completion_string, ref CXCursorKind kind)
        {
            var arg1 = (int)kind;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionParent(completion_string, ref arg1);
            kind = (CXCursorKind)arg1;
            return result;
        }

        ///<summary>
        /// Retrieve the brief documentation comment attached to the declaration that corresponds to the given completion string.
        ///</summary>
        public static CXString getCompletionBriefComment(QuantumBinding.Clang.Interop.CXCompletionString completion_string)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionBriefComment(completion_string);
        }

        ///<summary>
        /// Retrieve a completion string for an arbitrary declaration or macro definition cursor.
        ///</summary>
        public static CXCompletionString getCursorCompletionString(QuantumBinding.Clang.Interop.CXCursor cursor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorCompletionString(cursor);
        }

        ///<summary>
        /// Retrieve the number of fix-its for the given completion index.
        ///</summary>
        public static uint getCompletionNumFixIts(QuantumBinding.Clang.Interop.CXCodeCompleteResults? results, uint completion_index)
        {
            var arg0 = ReferenceEquals(results, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(results.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionNumFixIts(arg0, completion_index);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// Fix-its that *must* be applied before inserting the text for the corresponding completion.
        ///</summary>
        public static CXString getCompletionFixIt(QuantumBinding.Clang.Interop.CXCodeCompleteResults? results, uint completion_index, uint fixit_index, QuantumBinding.Clang.Interop.CXSourceRange? replacement_range)
        {
            var arg0 = ReferenceEquals(results, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(results.Value);
            var arg1 = ReferenceEquals(replacement_range, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(replacement_range.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionFixIt(arg0, completion_index, fixit_index, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Perform code completion at a given location in a translation unit.
        ///</summary>
        public static CXCodeCompleteResults codeCompleteAt(QuantumBinding.Clang.Interop.CXTranslationUnit TU, string complete_filename, uint complete_line, uint complete_column, QuantumBinding.Clang.Interop.CXUnsavedFile? unsaved_files, uint num_unsaved_files, uint options)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteAt(TU, complete_filename, complete_line, complete_column, arg1, num_unsaved_files, options);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Sort the code-completion results in case-insensitive alphabetical order.
        ///</summary>
        public static void sortCodeCompletionResults(QuantumBinding.Clang.Interop.CXCodeCompleteResults[] Results, uint NumResults)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (int i = 0; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i];
                }
            }
            QuantumBinding.Clang.Interop.ClangInterop.clang_sortCodeCompletionResults(arg0, NumResults);
        }

        ///<summary>
        /// Free the given set of code-completion results.
        ///</summary>
        public static void disposeCodeCompleteResults(QuantumBinding.Clang.Interop.CXCodeCompleteResults? Results)
        {
            var arg0 = ReferenceEquals(Results, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(Results.Value);
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeCodeCompleteResults(arg0);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Determine the number of diagnostics produced prior to the location where code completion was performed.
        ///</summary>
        public static uint codeCompleteGetNumDiagnostics(QuantumBinding.Clang.Interop.CXCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (int i = 0; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i];
                }
            }
            return QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetNumDiagnostics(arg0);
        }

        ///<summary>
        /// Retrieve a diagnostic associated with the given code completion.
        ///</summary>
        public static CXDiagnostic codeCompleteGetDiagnostic(QuantumBinding.Clang.Interop.CXCodeCompleteResults[] Results, uint Index)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (int i = 0; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i];
                }
            }
            return QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetDiagnostic(arg0, Index);
        }

        ///<summary>
        /// Determines what completions are appropriate for the context the given code completion.
        ///</summary>
        public static ulong codeCompleteGetContexts(QuantumBinding.Clang.Interop.CXCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (int i = 0; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i];
                }
            }
            return QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetContexts(arg0);
        }

        ///<summary>
        /// Returns the cursor kind for the container for the current code completion context. The container is only guaranteed to be set for contexts where a container exists (i.e. member accesses or Objective-C message sends); if there is not a container, this function will return CXCursor_InvalidCode.
        ///</summary>
        public static CXCursorKind codeCompleteGetContainerKind(QuantumBinding.Clang.Interop.CXCodeCompleteResults[] Results, out uint IsIncomplete)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (int i = 0; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i];
                }
            }
            return QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetContainerKind(arg0, out IsIncomplete);
        }

        ///<summary>
        /// Returns the USR for the container for the current code completion context. If there is not a container for the current context, this function will return the empty string.
        ///</summary>
        public static CXString codeCompleteGetContainerUSR(QuantumBinding.Clang.Interop.CXCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (int i = 0; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i];
                }
            }
            return QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetContainerUSR(arg0);
        }

        ///<summary>
        /// Returns the currently-entered selector for an Objective-C message send, formatted like "initWithFoo:bar:". Only guaranteed to return a non-empty string for CXCompletionContext_ObjCInstanceMessage and CXCompletionContext_ObjCClassMessage.
        ///</summary>
        public static CXString codeCompleteGetObjCSelector(QuantumBinding.Clang.Interop.CXCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (int i = 0; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i];
                }
            }
            return QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetObjCSelector(arg0);
        }

        ///<summary>
        /// Enable/disable crash recovery.
        ///</summary>
        public static void toggleCrashRecovery(uint isEnabled)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_toggleCrashRecovery(isEnabled);
        }

        ///<summary>
        /// Visit the set of preprocessor inclusions in a translation unit. The visitor function is called with the provided data for every included file. This does not include headers included by the PCH file (unless one is inspecting the inclusions in the PCH file itself).
        ///</summary>
        public static void getInclusions(QuantumBinding.Clang.Interop.CXTranslationUnit tu, CXInclusionVisitor visitor, QuantumBinding.Clang.Interop.CXClientData client_data)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_getInclusions(tu, visitor, client_data);
        }

        ///<summary>
        /// If cursor is a statement declaration tries to evaluate the statement and if its variable, tries to evaluate its initializer, into its corresponding type.
        ///</summary>
        public static CXEvalResult Cursor_Evaluate(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_Evaluate(C);
        }

        ///<summary>
        /// Returns the kind of the evaluated result.
        ///</summary>
        public static CXEvalResultKind EvalResult_getKind(QuantumBinding.Clang.Interop.CXEvalResult E)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getKind(E);
        }

        ///<summary>
        /// Returns the evaluation result as integer if the kind is Int.
        ///</summary>
        public static int EvalResult_getAsInt(QuantumBinding.Clang.Interop.CXEvalResult E)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsInt(E);
        }

        ///<summary>
        /// Returns the evaluation result as a long long integer if the kind is Int. This prevents overflows that may happen if the result is returned with clang_EvalResult_getAsInt.
        ///</summary>
        public static long EvalResult_getAsLongLong(QuantumBinding.Clang.Interop.CXEvalResult E)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsLongLong(E);
        }

        ///<summary>
        /// Returns a non-zero value if the kind is Int and the evaluation result resulted in an unsigned integer.
        ///</summary>
        public static uint EvalResult_isUnsignedInt(QuantumBinding.Clang.Interop.CXEvalResult E)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_isUnsignedInt(E);
        }

        ///<summary>
        /// Returns the evaluation result as an unsigned integer if the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.
        ///</summary>
        public static ulong EvalResult_getAsUnsigned(QuantumBinding.Clang.Interop.CXEvalResult E)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsUnsigned(E);
        }

        ///<summary>
        /// Returns the evaluation result as double if the kind is double.
        ///</summary>
        public static double EvalResult_getAsDouble(QuantumBinding.Clang.Interop.CXEvalResult E)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsDouble(E);
        }

        ///<summary>
        /// Returns the evaluation result as a constant string if the kind is other than Int or float. User must not free this pointer, instead call clang_EvalResult_dispose on the CXEvalResult returned by clang_Cursor_Evaluate.
        ///</summary>
        public static string EvalResult_getAsStr(QuantumBinding.Clang.Interop.CXEvalResult E)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsStr(E);
        }

        ///<summary>
        /// Disposes the created Eval memory.
        ///</summary>
        public static void EvalResult_dispose(QuantumBinding.Clang.Interop.CXEvalResult E)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_dispose(E);
        }

        ///<summary>
        /// Retrieve a remapping.
        ///</summary>
        public static CXRemapping getRemappings(string path)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getRemappings(path);
        }

        ///<summary>
        /// Retrieve a remapping.
        ///</summary>
        public static CXRemapping getRemappingsFromFileList(in string[] filePaths, uint numFiles)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getRemappingsFromFileList(filePaths, numFiles);
        }

        ///<summary>
        /// Determine the number of remappings.
        ///</summary>
        public static uint remap_getNumFiles(QuantumBinding.Clang.Interop.CXRemapping param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_remap_getNumFiles(param0);
        }

        ///<summary>
        /// Get the original and the associated filename from the remapping.
        ///</summary>
        public static void remap_getFilenames(QuantumBinding.Clang.Interop.CXRemapping param0, uint index, out QuantumBinding.Clang.Interop.CXString original, out QuantumBinding.Clang.Interop.CXString transformed)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_remap_getFilenames(param0, index, out original, out transformed);
        }

        ///<summary>
        /// Dispose the remapping.
        ///</summary>
        public static void remap_dispose(QuantumBinding.Clang.Interop.CXRemapping param0)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_remap_dispose(param0);
        }

        ///<summary>
        /// Find references of a declaration in a specific file.
        ///</summary>
        public static CXResult findReferencesInFile(QuantumBinding.Clang.Interop.CXCursor cursor, QuantumBinding.Clang.Interop.CXFile file, QuantumBinding.Clang.Interop.CXCursorAndRangeVisitor visitor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_findReferencesInFile(cursor, file, visitor);
        }

        ///<summary>
        /// Find #import/#include directives in a specific file.
        ///</summary>
        public static CXResult findIncludesInFile(QuantumBinding.Clang.Interop.CXTranslationUnit TU, QuantumBinding.Clang.Interop.CXFile file, QuantumBinding.Clang.Interop.CXCursorAndRangeVisitor visitor)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_findIncludesInFile(TU, file, visitor);
        }

        public static int index_isEntityObjCContainerKind(CXIdxEntityKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_index_isEntityObjCContainerKind(param0);
        }

        public static CXIdxObjCContainerDeclInfo index_getObjCContainerDeclInfo(in QuantumBinding.Clang.Interop.CXIdxDeclInfo? param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCContainerDeclInfo(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxObjCInterfaceDeclInfo index_getObjCInterfaceDeclInfo(in QuantumBinding.Clang.Interop.CXIdxDeclInfo? param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCInterfaceDeclInfo(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxObjCCategoryDeclInfo index_getObjCCategoryDeclInfo(in QuantumBinding.Clang.Interop.CXIdxDeclInfo? param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCCategoryDeclInfo(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxObjCProtocolRefListInfo index_getObjCProtocolRefListInfo(in QuantumBinding.Clang.Interop.CXIdxDeclInfo? param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCProtocolRefListInfo(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxObjCPropertyDeclInfo index_getObjCPropertyDeclInfo(in QuantumBinding.Clang.Interop.CXIdxDeclInfo? param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCPropertyDeclInfo(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxIBOutletCollectionAttrInfo index_getIBOutletCollectionAttrInfo(in QuantumBinding.Clang.Interop.CXIdxAttrInfo? param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getIBOutletCollectionAttrInfo(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxCXXClassDeclInfo index_getCXXClassDeclInfo(in QuantumBinding.Clang.Interop.CXIdxDeclInfo? param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getCXXClassDeclInfo(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// For retrieving a custom CXIdxClientContainer attached to a container.
        ///</summary>
        public static CXIdxClientContainer index_getClientContainer(in QuantumBinding.Clang.Interop.CXIdxContainerInfo? param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getClientContainer(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// For setting a custom CXIdxClientContainer attached to a container.
        ///</summary>
        public static void index_setClientContainer(in QuantumBinding.Clang.Interop.CXIdxContainerInfo? param0, QuantumBinding.Clang.Interop.CXIdxClientContainer param1)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            QuantumBinding.Clang.Interop.ClangInterop.clang_index_setClientContainer(arg0, param1);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// For retrieving a custom CXIdxClientEntity attached to an entity.
        ///</summary>
        public static CXIdxClientEntity index_getClientEntity(in QuantumBinding.Clang.Interop.CXIdxEntityInfo? param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getClientEntity(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// For setting a custom CXIdxClientEntity attached to an entity.
        ///</summary>
        public static void index_setClientEntity(in QuantumBinding.Clang.Interop.CXIdxEntityInfo? param0, QuantumBinding.Clang.Interop.CXIdxClientEntity param1)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.Value);
            QuantumBinding.Clang.Interop.ClangInterop.clang_index_setClientEntity(arg0, param1);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// An indexing action/session, to be applied to one or multiple translation units.
        ///</summary>
        public static CXIndexAction IndexAction_create(QuantumBinding.Clang.Interop.CXIndex CIdx)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_IndexAction_create(CIdx);
        }

        ///<summary>
        /// Destroy the given index action.
        ///</summary>
        public static void IndexAction_dispose(QuantumBinding.Clang.Interop.CXIndexAction param0)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_IndexAction_dispose(param0);
        }

        ///<summary>
        /// Index the given source file and the translation unit corresponding to that file via callbacks implemented through #IndexerCallbacks.
        ///</summary>
        public static int indexSourceFile(QuantumBinding.Clang.Interop.CXIndexAction param0, QuantumBinding.Clang.Interop.CXClientData client_data, QuantumBinding.Clang.Interop.IndexerCallbacks? index_callbacks, uint index_callbacks_size, uint index_options, string source_filename, in string[] command_line_args, int num_command_line_args, QuantumBinding.Clang.Interop.CXUnsavedFile? unsaved_files, uint num_unsaved_files, out QuantumBinding.Clang.Interop.CXTranslationUnit out_TU, uint TU_options)
        {
            var arg2 = ReferenceEquals(index_callbacks, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(index_callbacks.Value);
            var arg3 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexSourceFile(param0, client_data, arg2, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, arg3, num_unsaved_files, out out_TU, TU_options);
            Marshal.FreeHGlobal(arg2);
            Marshal.FreeHGlobal(arg3);
            return result;
        }

        ///<summary>
        /// Same as clang_indexSourceFile but requires a full command line for command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.
        ///</summary>
        public static int indexSourceFileFullArgv(QuantumBinding.Clang.Interop.CXIndexAction param0, QuantumBinding.Clang.Interop.CXClientData client_data, QuantumBinding.Clang.Interop.IndexerCallbacks? index_callbacks, uint index_callbacks_size, uint index_options, string source_filename, in string[] command_line_args, int num_command_line_args, QuantumBinding.Clang.Interop.CXUnsavedFile? unsaved_files, uint num_unsaved_files, out QuantumBinding.Clang.Interop.CXTranslationUnit out_TU, uint TU_options)
        {
            var arg2 = ReferenceEquals(index_callbacks, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(index_callbacks.Value);
            var arg3 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexSourceFileFullArgv(param0, client_data, arg2, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, arg3, num_unsaved_files, out out_TU, TU_options);
            Marshal.FreeHGlobal(arg2);
            Marshal.FreeHGlobal(arg3);
            return result;
        }

        ///<summary>
        /// Index the given translation unit via callbacks implemented through #IndexerCallbacks.
        ///</summary>
        public static int indexTranslationUnit(QuantumBinding.Clang.Interop.CXIndexAction param0, QuantumBinding.Clang.Interop.CXClientData client_data, QuantumBinding.Clang.Interop.IndexerCallbacks? index_callbacks, uint index_callbacks_size, uint index_options, QuantumBinding.Clang.Interop.CXTranslationUnit param5)
        {
            var arg2 = ReferenceEquals(index_callbacks, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(index_callbacks.Value);
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexTranslationUnit(param0, client_data, arg2, index_callbacks_size, index_options, param5);
            Marshal.FreeHGlobal(arg2);
            return result;
        }

        ///<summary>
        /// Retrieve the CXIdxFile, file, line, column, and offset represented by the given CXIdxLoc.
        ///</summary>
        public static void indexLoc_getFileLocation(QuantumBinding.Clang.Interop.CXIdxLoc loc, out QuantumBinding.Clang.Interop.CXIdxClientFile indexFile, out QuantumBinding.Clang.Interop.CXFile file, out uint line, out uint column, out uint offset)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_indexLoc_getFileLocation(loc, out indexFile, out file, out line, out column, out offset);
        }

        ///<summary>
        /// Retrieve the CXSourceLocation represented by the given CXIdxLoc.
        ///</summary>
        public static CXSourceLocation indexLoc_getCXSourceLocation(QuantumBinding.Clang.Interop.CXIdxLoc loc)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_indexLoc_getCXSourceLocation(loc);
        }

        ///<summary>
        /// Visit the fields of a particular type.
        ///</summary>
        public static uint Type_visitFields(QuantumBinding.Clang.Interop.CXType T, CXFieldVisitor visitor, QuantumBinding.Clang.Interop.CXClientData client_data)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Type_visitFields(T, visitor, client_data);
        }

        ///<summary>
        /// Given a cursor that represents a documentable entity (e.g., declaration), return the associated parsed comment as a CXComment_FullComment AST node.
        ///</summary>
        public static CXComment Cursor_getParsedComment(QuantumBinding.Clang.Interop.CXCursor C)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getParsedComment(C);
        }

        ///<summary>
        /// Returns the type of the AST node.
        ///</summary>
        public static CXCommentKind Comment_getKind(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Comment_getKind(Comment);
        }

        ///<summary>
        /// Returns number of children of the AST node.
        ///</summary>
        public static uint Comment_getNumChildren(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Comment_getNumChildren(Comment);
        }

        ///<summary>
        /// Returns the specified child of the AST node.
        ///</summary>
        public static CXComment Comment_getChild(QuantumBinding.Clang.Interop.CXComment Comment, uint ChildIdx)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Comment_getChild(Comment, ChildIdx);
        }

        ///<summary>
        /// A CXComment_Paragraph node is considered whitespace if it contains only CXComment_Text nodes that are empty or whitespace.
        ///</summary>
        public static uint Comment_isWhitespace(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Comment_isWhitespace(Comment);
        }

        ///<summary>
        /// Returns non-zero if Comment is inline content and has a newline immediately following it in the comment text. Newlines between paragraphs do not count.
        ///</summary>
        public static uint InlineContentComment_hasTrailingNewline(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_InlineContentComment_hasTrailingNewline(Comment);
        }

        ///<summary>
        /// Returns text contained in the AST node.
        ///</summary>
        public static CXString TextComment_getText(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TextComment_getText(Comment);
        }

        ///<summary>
        /// Returns name of the inline command.
        ///</summary>
        public static CXString InlineCommandComment_getCommandName(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_InlineCommandComment_getCommandName(Comment);
        }

        ///<summary>
        /// Returns the most appropriate rendering mode, chosen on command semantics in Doxygen.
        ///</summary>
        public static CXCommentInlineCommandRenderKind InlineCommandComment_getRenderKind(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_InlineCommandComment_getRenderKind(Comment);
        }

        ///<summary>
        /// Returns number of command arguments.
        ///</summary>
        public static uint InlineCommandComment_getNumArgs(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_InlineCommandComment_getNumArgs(Comment);
        }

        ///<summary>
        /// Returns text of the specified argument.
        ///</summary>
        public static CXString InlineCommandComment_getArgText(QuantumBinding.Clang.Interop.CXComment Comment, uint ArgIdx)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_InlineCommandComment_getArgText(Comment, ArgIdx);
        }

        ///<summary>
        /// Returns HTML tag name.
        ///</summary>
        public static CXString HTMLTagComment_getTagName(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLTagComment_getTagName(Comment);
        }

        ///<summary>
        /// Returns non-zero if tag is self-closing (for example, <br />).
        ///</summary>
        public static uint HTMLStartTagComment_isSelfClosing(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLStartTagComment_isSelfClosing(Comment);
        }

        ///<summary>
        /// Returns number of attributes (name-value pairs) attached to the start tag.
        ///</summary>
        public static uint HTMLStartTag_getNumAttrs(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLStartTag_getNumAttrs(Comment);
        }

        ///<summary>
        /// Returns name of the specified attribute.
        ///</summary>
        public static CXString HTMLStartTag_getAttrName(QuantumBinding.Clang.Interop.CXComment Comment, uint AttrIdx)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLStartTag_getAttrName(Comment, AttrIdx);
        }

        ///<summary>
        /// Returns value of the specified attribute.
        ///</summary>
        public static CXString HTMLStartTag_getAttrValue(QuantumBinding.Clang.Interop.CXComment Comment, uint AttrIdx)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLStartTag_getAttrValue(Comment, AttrIdx);
        }

        ///<summary>
        /// Returns name of the block command.
        ///</summary>
        public static CXString BlockCommandComment_getCommandName(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_BlockCommandComment_getCommandName(Comment);
        }

        ///<summary>
        /// Returns number of word-like arguments.
        ///</summary>
        public static uint BlockCommandComment_getNumArgs(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_BlockCommandComment_getNumArgs(Comment);
        }

        ///<summary>
        /// Returns text of the specified word-like argument.
        ///</summary>
        public static CXString BlockCommandComment_getArgText(QuantumBinding.Clang.Interop.CXComment Comment, uint ArgIdx)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_BlockCommandComment_getArgText(Comment, ArgIdx);
        }

        ///<summary>
        /// Returns paragraph argument of the block command.
        ///</summary>
        public static CXComment BlockCommandComment_getParagraph(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_BlockCommandComment_getParagraph(Comment);
        }

        ///<summary>
        /// Returns parameter name.
        ///</summary>
        public static CXString ParamCommandComment_getParamName(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_getParamName(Comment);
        }

        ///<summary>
        /// Returns non-zero if the parameter that this AST node represents was found in the function prototype and clang_ParamCommandComment_getParamIndex function will return a meaningful value.
        ///</summary>
        public static uint ParamCommandComment_isParamIndexValid(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_isParamIndexValid(Comment);
        }

        ///<summary>
        /// Returns zero-based parameter index in function prototype.
        ///</summary>
        public static uint ParamCommandComment_getParamIndex(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_getParamIndex(Comment);
        }

        ///<summary>
        /// Returns non-zero if parameter passing direction was specified explicitly in the comment.
        ///</summary>
        public static uint ParamCommandComment_isDirectionExplicit(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_isDirectionExplicit(Comment);
        }

        ///<summary>
        /// Returns parameter passing direction.
        ///</summary>
        public static CXCommentParamPassDirection ParamCommandComment_getDirection(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_getDirection(Comment);
        }

        ///<summary>
        /// Returns template parameter name.
        ///</summary>
        public static CXString TParamCommandComment_getParamName(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TParamCommandComment_getParamName(Comment);
        }

        ///<summary>
        /// Returns non-zero if the parameter that this AST node represents was found in the template parameter list and clang_TParamCommandComment_getDepth and clang_TParamCommandComment_getIndex functions will return a meaningful value.
        ///</summary>
        public static uint TParamCommandComment_isParamPositionValid(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TParamCommandComment_isParamPositionValid(Comment);
        }

        ///<summary>
        /// Returns zero-based nesting depth of this parameter in the template parameter list.
        ///</summary>
        public static uint TParamCommandComment_getDepth(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TParamCommandComment_getDepth(Comment);
        }

        ///<summary>
        /// Returns zero-based parameter index in the template parameter list at a given nesting depth.
        ///</summary>
        public static uint TParamCommandComment_getIndex(QuantumBinding.Clang.Interop.CXComment Comment, uint Depth)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TParamCommandComment_getIndex(Comment, Depth);
        }

        ///<summary>
        /// Returns text contained in the AST node.
        ///</summary>
        public static CXString VerbatimBlockLineComment_getText(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VerbatimBlockLineComment_getText(Comment);
        }

        ///<summary>
        /// Returns text contained in the AST node.
        ///</summary>
        public static CXString VerbatimLineComment_getText(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VerbatimLineComment_getText(Comment);
        }

        ///<summary>
        /// Convert an HTML tag AST node to string.
        ///</summary>
        public static CXString HTMLTagComment_getAsString(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLTagComment_getAsString(Comment);
        }

        ///<summary>
        /// Convert a given full parsed comment to an HTML fragment.
        ///</summary>
        public static CXString FullComment_getAsHTML(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_FullComment_getAsHTML(Comment);
        }

        ///<summary>
        /// Convert a given full parsed comment to an XML document.
        ///</summary>
        public static CXString FullComment_getAsXML(QuantumBinding.Clang.Interop.CXComment Comment)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_FullComment_getAsXML(Comment);
        }

    }

}

