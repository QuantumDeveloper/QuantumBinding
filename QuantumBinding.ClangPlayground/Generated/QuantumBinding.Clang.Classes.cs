// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

namespace QuantumBinding.Clang
{
    using System;
    using System.Runtime.InteropServices;
    using QuantumBinding.Clang.Interop;

    ///<summary>
    /// Object encapsulating information about overlaying virtual file/directories over the real file system.
    ///</summary>
    public partial class QBVirtualFileOverlay
    {
        internal CXVirtualFileOverlayImpl __Instance;

        public QBVirtualFileOverlay()
        {
        }

        public QBVirtualFileOverlay(QuantumBinding.Clang.Interop.CXVirtualFileOverlayImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Map an absolute virtual file path to an absolute real one. The virtual path must be canonicalized (not contain "."/"..").
        ///</summary>
        public CXErrorCode VirtualFileOverlay_addFileMapping(string virtualPath, string realPath)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_addFileMapping(this, virtualPath, realPath);
        }

        ///<summary>
        /// Dispose a CXVirtualFileOverlay object.
        ///</summary>
        public void VirtualFileOverlay_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_dispose(this);
        }

        ///<summary>
        /// Set the case sensitivity for the CXVirtualFileOverlay object. The CXVirtualFileOverlay object is case-sensitive by default, this option can be used to override the default.
        ///</summary>
        public CXErrorCode VirtualFileOverlay_setCaseSensitivity(int caseSensitive)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_setCaseSensitivity(this, caseSensitive);
        }

        ///<summary>
        /// Write out the CXVirtualFileOverlay object to a char buffer.
        ///</summary>
        public CXErrorCode VirtualFileOverlay_writeToBuffer(uint options, out System.IntPtr out_buffer_ptr, out uint out_buffer_size)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_writeToBuffer(this, options, out out_buffer_ptr, out out_buffer_size);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXVirtualFileOverlayImpl(QBVirtualFileOverlay q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXVirtualFileOverlayImpl();
        }

        public static implicit operator QBVirtualFileOverlay(QuantumBinding.Clang.Interop.CXVirtualFileOverlayImpl q)
        {
            return new QBVirtualFileOverlay(){__Instance = q};
        }

    }

    ///<summary>
    /// Object encapsulating information about a module.map file.
    ///</summary>
    public partial class QBModuleMapDescriptor
    {
        internal CXModuleMapDescriptorImpl __Instance;

        public QBModuleMapDescriptor()
        {
        }

        public QBModuleMapDescriptor(QuantumBinding.Clang.Interop.CXModuleMapDescriptorImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Dispose a CXModuleMapDescriptor object.
        ///</summary>
        public void ModuleMapDescriptor_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_dispose(this);
        }

        ///<summary>
        /// Sets the framework module name that the module.map describes.
        ///</summary>
        public CXErrorCode ModuleMapDescriptor_setFrameworkModuleName(string name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_setFrameworkModuleName(this, name);
        }

        ///<summary>
        /// Sets the umbrealla header name that the module.map describes.
        ///</summary>
        public CXErrorCode ModuleMapDescriptor_setUmbrellaHeader(string name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_setUmbrellaHeader(this, name);
        }

        ///<summary>
        /// Write out the CXModuleMapDescriptor object to a char buffer.
        ///</summary>
        public CXErrorCode ModuleMapDescriptor_writeToBuffer(uint options, out System.IntPtr out_buffer_ptr, out uint out_buffer_size)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_writeToBuffer(this, options, out out_buffer_ptr, out out_buffer_size);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXModuleMapDescriptorImpl(QBModuleMapDescriptor q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXModuleMapDescriptorImpl();
        }

        public static implicit operator QBModuleMapDescriptor(QuantumBinding.Clang.Interop.CXModuleMapDescriptorImpl q)
        {
            return new QBModuleMapDescriptor(){__Instance = q};
        }

    }

    ///<summary>
    /// An "index" that consists of a set of translation units that would typically be linked together into an executable or library.
    ///</summary>
    public partial class QBIndex
    {
        internal CXIndexImpl __Instance;

        public QBIndex()
        {
        }

        public QBIndex(QuantumBinding.Clang.Interop.CXIndexImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Same as clang_createTranslationUnit2, but returns the CXTranslationUnit instead of an error code. In case of an error this routine returns a NULL CXTranslationUnit, without further detailed error codes.
        ///</summary>
        public QBTranslationUnit createTranslationUnit(string ast_filename)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_createTranslationUnit(this, ast_filename);
        }

        ///<summary>
        /// Create a translation unit from an AST file ( -emit-ast).
        ///</summary>
        public CXErrorCode createTranslationUnit2(string ast_filename, out QuantumBinding.Clang.QBTranslationUnit out_TU)
        {
            CXTranslationUnitImpl arg1;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_createTranslationUnit2(this, ast_filename, out arg1);
            out_TU = new QBTranslationUnit(arg1);
            return result;
        }

        ///<summary>
        /// Return the CXTranslationUnit for a given source file and the provided command line arguments one would pass to the compiler.
        ///</summary>
        public QBTranslationUnit createTranslationUnitFromSourceFile(string source_filename, int num_clang_command_line_args, in string[] clang_command_line_args, uint num_unsaved_files, QBUnsavedFile unsaved_files)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_createTranslationUnitFromSourceFile(this, source_filename, num_clang_command_line_args, clang_command_line_args, num_unsaved_files, arg1);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Gets the general options associated with a CXIndex.
        ///</summary>
        public uint CXIndex_getGlobalOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXIndex_getGlobalOptions(this);
        }

        ///<summary>
        /// Sets general options associated with a CXIndex.
        ///</summary>
        public void CXIndex_setGlobalOptions(uint options)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_CXIndex_setGlobalOptions(this, options);
        }

        ///<summary>
        /// Sets the invocation emission path option in a CXIndex.
        ///</summary>
        public void CXIndex_setInvocationEmissionPathOption(string Path)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_CXIndex_setInvocationEmissionPathOption(this, Path);
        }

        ///<summary>
        /// Destroy the given index.
        ///</summary>
        public void disposeIndex()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeIndex(this);
        }

        ///<summary>
        /// An indexing action/session, to be applied to one or multiple translation units.
        ///</summary>
        public QBIndexAction IndexAction_create()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_IndexAction_create(this);
        }

        ///<summary>
        /// Same as clang_parseTranslationUnit2, but returns the CXTranslationUnit instead of an error code. In case of an error this routine returns a NULL CXTranslationUnit, without further detailed error codes.
        ///</summary>
        public QBTranslationUnit parseTranslationUnit(string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile unsaved_files, uint num_unsaved_files, uint options)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_parseTranslationUnit(this, source_filename, command_line_args, num_command_line_args, arg1, num_unsaved_files, options);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Parse the given source file and the translation unit corresponding to that file.
        ///</summary>
        public CXErrorCode parseTranslationUnit2(string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile[] unsaved_files, uint num_unsaved_files, uint options, out QuantumBinding.Clang.QBTranslationUnit out_TU)
        {
            QuantumBinding.Clang.Interop.CXUnsavedFile[] arg1 = null;
            arg1 = ReferenceEquals(unsaved_files, null) ? null : new QuantumBinding.Clang.Interop.CXUnsavedFile[unsaved_files.Length];
            if (!ReferenceEquals(unsaved_files, null))
            {
                for (var i = 0U; i < unsaved_files.Length; ++i)
                {
                    arg1[i] = unsaved_files[i].ToInternal();
                }
            }
            CXTranslationUnitImpl arg2;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_parseTranslationUnit2(this, source_filename, command_line_args, num_command_line_args, arg1, num_unsaved_files, options, out arg2);
            if (!ReferenceEquals(unsaved_files, null))
            {
                for (var i = 0U; i < unsaved_files.Length; ++i)
                {
                    unsaved_files[i]?.Dispose();
                }
            }
            out_TU = new QBTranslationUnit(arg2);
            return result;
        }

        ///<summary>
        /// Same as clang_parseTranslationUnit2 but requires a full command line for command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.
        ///</summary>
        public CXErrorCode parseTranslationUnit2FullArgv(string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile unsaved_files, uint num_unsaved_files, uint options, out QuantumBinding.Clang.QBTranslationUnit out_TU)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            CXTranslationUnitImpl arg2;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_parseTranslationUnit2FullArgv(this, source_filename, command_line_args, num_command_line_args, arg1, num_unsaved_files, options, out arg2);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            out_TU = new QBTranslationUnit(arg2);
            return result;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIndexImpl(QBIndex q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIndexImpl();
        }

        public static implicit operator QBIndex(QuantumBinding.Clang.Interop.CXIndexImpl q)
        {
            return new QBIndex(){__Instance = q};
        }

    }

    ///<summary>
    /// An opaque type representing target information for a given translation unit.
    ///</summary>
    public partial class QBTargetInfo
    {
        internal CXTargetInfoImpl __Instance;

        public QBTargetInfo()
        {
        }

        public QBTargetInfo(QuantumBinding.Clang.Interop.CXTargetInfoImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Destroy the CXTargetInfo object.
        ///</summary>
        public void TargetInfo_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_TargetInfo_dispose(this);
        }

        ///<summary>
        /// Get the pointer width of the target in bits.
        ///</summary>
        public int TargetInfo_getPointerWidth()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TargetInfo_getPointerWidth(this);
        }

        ///<summary>
        /// Get the normalized target triple as a string.
        ///</summary>
        public CXString TargetInfo_getTriple()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TargetInfo_getTriple(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXTargetInfoImpl(QBTargetInfo q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXTargetInfoImpl();
        }

        public static implicit operator QBTargetInfo(QuantumBinding.Clang.Interop.CXTargetInfoImpl q)
        {
            return new QBTargetInfo(){__Instance = q};
        }

    }

    ///<summary>
    /// A single translation unit, which resides in an index.
    ///</summary>
    public partial class QBTranslationUnit
    {
        internal CXTranslationUnitImpl __Instance;

        public QBTranslationUnit()
        {
        }

        public QBTranslationUnit(QuantumBinding.Clang.Interop.CXTranslationUnitImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Annotate the given set of tokens by providing cursors for each token that can be mapped to a specific entity within the abstract syntax tree.
        ///</summary>
        public void annotateTokens(QBToken[] Tokens, uint NumTokens, out QBCursor[] Cursors)
        {
            QuantumBinding.Clang.Interop.CXToken[] arg1 = null;
            arg1 = ReferenceEquals(Tokens, null) ? null : new QuantumBinding.Clang.Interop.CXToken[Tokens.Length];
            if (!ReferenceEquals(Tokens, null))
            {
                for (var i = 0U; i < Tokens.Length; ++i)
                {
                    arg1[i] = Tokens[i].ToInternal();
                }
            }
            var arg2 = System.IntPtr.Zero;
            QuantumBinding.Clang.Interop.ClangInterop.clang_annotateTokens(this, arg1, NumTokens, ref arg2);
            if (!ReferenceEquals(Tokens, null))
            {
                for (var i = 0U; i < Tokens.Length; ++i)
                {
                    Tokens[i]?.Dispose();
                }
            }
            var _Cursors = new QuantumBinding.Clang.Interop.CXCursor[NumTokens];
            MarshalUtils.IntPtrToManagedArray<QuantumBinding.Clang.Interop.CXCursor>(arg2, _Cursors);
            Cursors = new QBCursor[NumTokens];
            for (var i = 0U; i< NumTokens; ++i)
            {
                Cursors[i] = new QBCursor(_Cursors[i]);
            }
        }

        ///<summary>
        /// Perform code completion at a given location in a translation unit.
        ///</summary>
        public CXCodeCompleteResults codeCompleteAt(string complete_filename, uint complete_line, uint complete_column, QBUnsavedFile unsaved_files, uint num_unsaved_files, uint options)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteAt(this, complete_filename, complete_line, complete_column, arg1, num_unsaved_files, options);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Returns the set of flags that is suitable for reparsing a translation unit.
        ///</summary>
        public uint defaultReparseOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultReparseOptions(this);
        }

        ///<summary>
        /// Returns the set of flags that is suitable for saving a translation unit.
        ///</summary>
        public uint defaultSaveOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultSaveOptions(this);
        }

        ///<summary>
        /// Free the given set of tokens.
        ///</summary>
        public void disposeTokens(System.IntPtr Tokens, uint NumTokens)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeTokens(this, Tokens, NumTokens);
        }

        ///<summary>
        /// Destroy the specified CXTranslationUnit object.
        ///</summary>
        public void disposeTranslationUnit()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeTranslationUnit(this);
        }

        ///<summary>
        /// Find #import/#include directives in a specific file.
        ///</summary>
        public CXResult findIncludesInFile(QuantumBinding.Clang.QBFile file, QBCursorAndRangeVisitor visitor)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            var arg2 = ReferenceEquals(visitor, null) ? new QuantumBinding.Clang.Interop.CXCursorAndRangeVisitor() : visitor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_findIncludesInFile(this, arg1, arg2);
            visitor?.Dispose();
            return result;
        }

        ///<summary>
        /// Retrieve all ranges from all files that were skipped by the preprocessor.
        ///</summary>
        public CXSourceRangeList getAllSkippedRanges()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getAllSkippedRanges(this);
        }

        ///<summary>
        /// Map a source location to the cursor that describes the entity at that location in the source code.
        ///</summary>
        public CXCursor getCursor(QBSourceLocation param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : param1.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursor(this, arg1);
            return result;
        }

        ///<summary>
        /// Return the memory usage of a translation unit. This object should be released with clang_disposeCXTUResourceUsage().
        ///</summary>
        public CXTUResourceUsage getCXTUResourceUsage()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCXTUResourceUsage(this);
        }

        ///<summary>
        /// Retrieve a diagnostic associated with the given translation unit.
        ///</summary>
        public QBDiagnostic getDiagnostic(uint Index)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnostic(this, Index);
        }

        ///<summary>
        /// Retrieve the complete set of diagnostics associated with a translation unit.
        ///</summary>
        public QBDiagnosticSet getDiagnosticSetFromTU()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticSetFromTU(this);
        }

        ///<summary>
        /// Retrieve a file handle within the given translation unit.
        ///</summary>
        public QBFile getFile(string file_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFile(this, file_name);
        }

        ///<summary>
        /// Retrieve the buffer associated with the given file.
        ///</summary>
        public string getFileContents(QuantumBinding.Clang.QBFile file, out ulong size)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileContents(this, arg1, out size);
        }

        ///<summary>
        /// Visit the set of preprocessor inclusions in a translation unit. The visitor function is called with the provided data for every included file. This does not include headers included by the PCH file (unless one is inspecting the inclusions in the PCH file itself).
        ///</summary>
        public void getInclusions(System.IntPtr visitor, QuantumBinding.Clang.QBClientData client_data)
        {
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            QuantumBinding.Clang.Interop.ClangInterop.clang_getInclusions(this, visitor, arg1);
        }

        ///<summary>
        /// Retrieves the source location associated with a given file/line/column in a particular translation unit.
        ///</summary>
        public CXSourceLocation getLocation(QuantumBinding.Clang.QBFile file, uint line, uint column)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getLocation(this, arg1, line, column);
        }

        ///<summary>
        /// Retrieves the source location associated with a given character offset in a particular translation unit.
        ///</summary>
        public CXSourceLocation getLocationForOffset(QuantumBinding.Clang.QBFile file, uint offset)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getLocationForOffset(this, arg1, offset);
        }

        ///<summary>
        /// Given a CXFile header file, return the module that contains it, if one exists.
        ///</summary>
        public QBModule getModuleForFile(QuantumBinding.Clang.QBFile param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new CXFileImpl() : (CXFileImpl)param1;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getModuleForFile(this, arg1);
        }

        ///<summary>
        /// Determine the number of diagnostics produced for the given translation unit.
        ///</summary>
        public uint getNumDiagnostics()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumDiagnostics(this);
        }

        ///<summary>
        /// Retrieve all ranges that were skipped by the preprocessor.
        ///</summary>
        public CXSourceRangeList getSkippedRanges(QuantumBinding.Clang.QBFile file)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getSkippedRanges(this, arg1);
        }

        ///<summary>
        /// Get the raw lexical token starting with the given location.
        ///</summary>
        public CXToken getToken(QBSourceLocation Location)
        {
            var arg1 = ReferenceEquals(Location, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : Location.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getToken(this, arg1);
            return result;
        }

        ///<summary>
        /// Retrieve a source range that covers the given token.
        ///</summary>
        public CXSourceRange getTokenExtent(QBToken param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new QuantumBinding.Clang.Interop.CXToken() : param1.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenExtent(this, arg1);
            param1?.Dispose();
            return result;
        }

        ///<summary>
        /// Retrieve the source location of the given token.
        ///</summary>
        public CXSourceLocation getTokenLocation(QBToken param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new QuantumBinding.Clang.Interop.CXToken() : param1.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenLocation(this, arg1);
            param1?.Dispose();
            return result;
        }

        ///<summary>
        /// Determine the spelling of the given token.
        ///</summary>
        public CXString getTokenSpelling(QBToken param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new QuantumBinding.Clang.Interop.CXToken() : param1.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenSpelling(this, arg1);
            param1?.Dispose();
            return result;
        }

        ///<summary>
        /// Retrieve the cursor that represents the given translation unit.
        ///</summary>
        public CXCursor getTranslationUnitCursor()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTranslationUnitCursor(this);
        }

        ///<summary>
        /// Get the original translation unit source file name.
        ///</summary>
        public CXString getTranslationUnitSpelling()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTranslationUnitSpelling(this);
        }

        ///<summary>
        /// Get target information for this translation unit.
        ///</summary>
        public QBTargetInfo getTranslationUnitTargetInfo()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTranslationUnitTargetInfo(this);
        }

        ///<summary>
        /// Determine whether the given header is guarded against multiple inclusions, either with the conventional #ifndef/#define/#endif macro guards or with #pragma once.
        ///</summary>
        public uint isFileMultipleIncludeGuarded(QuantumBinding.Clang.QBFile file)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isFileMultipleIncludeGuarded(this, arg1);
        }

        ///<summary>
        /// Returns the number of top level headers associated with this module.
        ///</summary>
        public uint Module_getNumTopLevelHeaders(QuantumBinding.Clang.QBModule Module)
        {
            var arg1 = ReferenceEquals(Module, null) ? new CXModuleImpl() : (CXModuleImpl)Module;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getNumTopLevelHeaders(this, arg1);
        }

        ///<summary>
        /// Returns the specified top level header associated with the module.
        ///</summary>
        public QBFile Module_getTopLevelHeader(QuantumBinding.Clang.QBModule Module, uint Index)
        {
            var arg1 = ReferenceEquals(Module, null) ? new CXModuleImpl() : (CXModuleImpl)Module;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getTopLevelHeader(this, arg1, Index);
        }

        ///<summary>
        /// Reparse the source files that produced this translation unit.
        ///</summary>
        public int reparseTranslationUnit(uint num_unsaved_files, QBUnsavedFile unsaved_files, uint options)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_reparseTranslationUnit(this, num_unsaved_files, arg1, options);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Saves a translation unit into a serialized representation of that translation unit on disk.
        ///</summary>
        public int saveTranslationUnit(string FileName, uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_saveTranslationUnit(this, FileName, options);
        }

        ///<summary>
        /// Suspend a translation unit in order to free memory associated with it.
        ///</summary>
        public uint suspendTranslationUnit()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_suspendTranslationUnit(this);
        }

        ///<summary>
        /// Tokenize the source code described by the given range into raw lexical tokens.
        ///</summary>
        public void tokenize(QBSourceRange Range, out QBToken[] Tokens, out uint NumTokens)
        {
            var arg1 = ReferenceEquals(Range, null) ? new QuantumBinding.Clang.Interop.CXSourceRange() : Range.ToInternal();
            var arg2 = System.IntPtr.Zero;
            QuantumBinding.Clang.Interop.ClangInterop.clang_tokenize(this, arg1, ref arg2, out NumTokens);
            var _Tokens = new QuantumBinding.Clang.Interop.CXToken[NumTokens];
            MarshalUtils.IntPtrToManagedArray<QuantumBinding.Clang.Interop.CXToken>(arg2, _Tokens);
            Tokens = new QBToken[NumTokens];
            for (var i = 0U; i< NumTokens; ++i)
            {
                Tokens[i] = new QBToken(_Tokens[i]);
            }
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXTranslationUnitImpl(QBTranslationUnit q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXTranslationUnitImpl();
        }

        public static implicit operator QBTranslationUnit(QuantumBinding.Clang.Interop.CXTranslationUnitImpl q)
        {
            return new QBTranslationUnit(){__Instance = q};
        }

    }

    ///<summary>
    /// Opaque pointer representing client data that will be passed through to various callbacks and visitors.
    ///</summary>
    public partial class QBClientData
    {
        internal CXClientDataImpl __Instance;

        public QBClientData()
        {
        }

        public QBClientData(QuantumBinding.Clang.Interop.CXClientDataImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXClientDataImpl(QBClientData q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXClientDataImpl();
        }

        public static implicit operator QBClientData(QuantumBinding.Clang.Interop.CXClientDataImpl q)
        {
            return new QBClientData(){__Instance = q};
        }

    }

    ///<summary>
    /// A particular source file that is part of a translation unit.
    ///</summary>
    public partial class QBFile
    {
        internal CXFileImpl __Instance;

        public QBFile()
        {
        }

        public QBFile(QuantumBinding.Clang.Interop.CXFileImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Returns non-zero if the file1 and file2 point to the same file, or they are both NULL.
        ///</summary>
        public int File_isEqual(QuantumBinding.Clang.QBFile file2)
        {
            var arg1 = ReferenceEquals(file2, null) ? new CXFileImpl() : (CXFileImpl)file2;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_File_isEqual(this, arg1);
        }

        ///<summary>
        /// Returns the real path name of file.
        ///</summary>
        public CXString File_tryGetRealPathName()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_File_tryGetRealPathName(this);
        }

        ///<summary>
        /// Retrieve the complete file and path name of the given file.
        ///</summary>
        public CXString getFileName()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileName(this);
        }

        ///<summary>
        /// Retrieve the last modification time of the given file.
        ///</summary>
        public long getFileTime()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileTime(this);
        }

        ///<summary>
        /// Retrieve the unique ID for the given file.
        ///</summary>
        public int getFileUniqueID(out QBFileUniqueID outID)
        {
            CXFileUniqueID arg1;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getFileUniqueID(this, out arg1);
            outID = new QBFileUniqueID(arg1);
            return result;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXFileImpl(QBFile q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXFileImpl();
        }

        public static implicit operator QBFile(QuantumBinding.Clang.Interop.CXFileImpl q)
        {
            return new QBFile(){__Instance = q};
        }

    }

    ///<summary>
    /// A single diagnostic, containing the diagnostic's severity, location, text, source ranges, and fix-it hints.
    ///</summary>
    public partial class QBDiagnostic
    {
        internal CXDiagnosticImpl __Instance;

        public QBDiagnostic()
        {
        }

        public QBDiagnostic(QuantumBinding.Clang.Interop.CXDiagnosticImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Destroy a diagnostic.
        ///</summary>
        public void disposeDiagnostic()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeDiagnostic(this);
        }

        ///<summary>
        /// Format the given diagnostic in a manner that is suitable for display.
        ///</summary>
        public CXString formatDiagnostic(uint Options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_formatDiagnostic(this, Options);
        }

        ///<summary>
        /// Retrieve the child diagnostics of a CXDiagnostic.
        ///</summary>
        public QBDiagnosticSet getChildDiagnostics()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getChildDiagnostics(this);
        }

        ///<summary>
        /// Retrieve the category number for this diagnostic.
        ///</summary>
        public uint getDiagnosticCategory()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticCategory(this);
        }

        ///<summary>
        /// Retrieve the diagnostic category text for a given diagnostic.
        ///</summary>
        public CXString getDiagnosticCategoryText()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticCategoryText(this);
        }

        ///<summary>
        /// Retrieve the replacement information for a given fix-it.
        ///</summary>
        public CXString getDiagnosticFixIt(uint FixIt, QBSourceRange ReplacementRange)
        {
            var arg1 = ReferenceEquals(ReplacementRange, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(ReplacementRange.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticFixIt(this, FixIt, arg1);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Retrieve the source location of the given diagnostic.
        ///</summary>
        public CXSourceLocation getDiagnosticLocation()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticLocation(this);
        }

        ///<summary>
        /// Determine the number of fix-it hints associated with the given diagnostic.
        ///</summary>
        public uint getDiagnosticNumFixIts()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticNumFixIts(this);
        }

        ///<summary>
        /// Determine the number of source ranges associated with the given diagnostic.
        ///</summary>
        public uint getDiagnosticNumRanges()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticNumRanges(this);
        }

        ///<summary>
        /// Retrieve the name of the command-line option that enabled this diagnostic.
        ///</summary>
        public CXString getDiagnosticOption(QBString Disable)
        {
            var arg1 = ReferenceEquals(Disable, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(Disable.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticOption(this, arg1);
            Disable?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Retrieve a source range associated with the diagnostic.
        ///</summary>
        public CXSourceRange getDiagnosticRange(uint Range)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticRange(this, Range);
        }

        ///<summary>
        /// Determine the severity of the given diagnostic.
        ///</summary>
        public CXDiagnosticSeverity getDiagnosticSeverity()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticSeverity(this);
        }

        ///<summary>
        /// Retrieve the text of the given diagnostic.
        ///</summary>
        public CXString getDiagnosticSpelling()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticSpelling(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXDiagnosticImpl(QBDiagnostic q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXDiagnosticImpl();
        }

        public static implicit operator QBDiagnostic(QuantumBinding.Clang.Interop.CXDiagnosticImpl q)
        {
            return new QBDiagnostic(){__Instance = q};
        }

    }

    ///<summary>
    /// A group of CXDiagnostics.
    ///</summary>
    public partial class QBDiagnosticSet
    {
        internal CXDiagnosticSetImpl __Instance;

        public QBDiagnosticSet()
        {
        }

        public QBDiagnosticSet(QuantumBinding.Clang.Interop.CXDiagnosticSetImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Release a CXDiagnosticSet and all of its contained diagnostics.
        ///</summary>
        public void disposeDiagnosticSet()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeDiagnosticSet(this);
        }

        ///<summary>
        /// Retrieve a diagnostic associated with the given CXDiagnosticSet.
        ///</summary>
        public QBDiagnostic getDiagnosticInSet(uint Index)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticInSet(this, Index);
        }

        ///<summary>
        /// Determine the number of diagnostics in a CXDiagnosticSet.
        ///</summary>
        public uint getNumDiagnosticsInSet()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumDiagnosticsInSet(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXDiagnosticSetImpl(QBDiagnosticSet q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXDiagnosticSetImpl();
        }

        public static implicit operator QBDiagnosticSet(QuantumBinding.Clang.Interop.CXDiagnosticSetImpl q)
        {
            return new QBDiagnosticSet(){__Instance = q};
        }

    }

    ///<summary>
    /// A fast container representing a set of CXCursors.
    ///</summary>
    public partial class QBCursorSet
    {
        internal CXCursorSetImpl __Instance;

        public QBCursorSet()
        {
        }

        public QBCursorSet(QuantumBinding.Clang.Interop.CXCursorSetImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Creates an empty CXCursorSet.
        ///</summary>
        public static QBCursorSet createCXCursorSet()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_createCXCursorSet();
        }

        ///<summary>
        /// Queries a CXCursorSet to see if it contains a specific CXCursor.
        ///</summary>
        public uint CXCursorSet_contains(QBCursor cursor)
        {
            var arg1 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXCursorSet_contains(this, arg1);
            return result;
        }

        ///<summary>
        /// Inserts a CXCursor into a CXCursorSet.
        ///</summary>
        public uint CXCursorSet_insert(QBCursor cursor)
        {
            var arg1 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXCursorSet_insert(this, arg1);
            return result;
        }

        ///<summary>
        /// Disposes a CXCursorSet and releases its associated memory.
        ///</summary>
        public void disposeCXCursorSet()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeCXCursorSet(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXCursorSetImpl(QBCursorSet q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXCursorSetImpl();
        }

        public static implicit operator QBCursorSet(QuantumBinding.Clang.Interop.CXCursorSetImpl q)
        {
            return new QBCursorSet(){__Instance = q};
        }

    }

    ///<summary>
    /// Opaque pointer representing a policy that controls pretty printing for clang_getCursorPrettyPrinted.
    ///</summary>
    public partial class QBPrintingPolicy
    {
        internal CXPrintingPolicyImpl __Instance;

        public QBPrintingPolicy()
        {
        }

        public QBPrintingPolicy(QuantumBinding.Clang.Interop.CXPrintingPolicyImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Release a printing policy.
        ///</summary>
        public void PrintingPolicy_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_PrintingPolicy_dispose(this);
        }

        ///<summary>
        /// Get a property value for the given printing policy.
        ///</summary>
        public uint PrintingPolicy_getProperty(CXPrintingPolicyProperty Property)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_PrintingPolicy_getProperty(this, Property);
        }

        ///<summary>
        /// Set a property value for the given printing policy.
        ///</summary>
        public void PrintingPolicy_setProperty(CXPrintingPolicyProperty Property, uint Value)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_PrintingPolicy_setProperty(this, Property, Value);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXPrintingPolicyImpl(QBPrintingPolicy q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXPrintingPolicyImpl();
        }

        public static implicit operator QBPrintingPolicy(QuantumBinding.Clang.Interop.CXPrintingPolicyImpl q)
        {
            return new QBPrintingPolicy(){__Instance = q};
        }

    }

    ///<summary>
    /// The functions in this group provide access to information about modules.
    ///</summary>
    public partial class QBModule
    {
        internal CXModuleImpl __Instance;

        public QBModule()
        {
        }

        public QBModule(QuantumBinding.Clang.Interop.CXModuleImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Returns the module file where the provided module object came from.
        ///</summary>
        public QBFile Module_getASTFile()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getASTFile(this);
        }

        ///<summary>
        /// Returns the full name of the module, e.g. "std.vector".
        ///</summary>
        public CXString Module_getFullName()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getFullName(this);
        }

        ///<summary>
        /// Returns the name of the module, e.g. for the 'std.vector' sub-module it will return "vector".
        ///</summary>
        public CXString Module_getName()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getName(this);
        }

        ///<summary>
        /// Returns the parent of a sub-module or NULL if the given module is top-level, e.g. for 'std.vector' it will return the 'std' module.
        ///</summary>
        public QBModule Module_getParent()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getParent(this);
        }

        ///<summary>
        /// Returns non-zero if the module is a system one.
        ///</summary>
        public int Module_isSystem()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_isSystem(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXModuleImpl(QBModule q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXModuleImpl();
        }

        public static implicit operator QBModule(QuantumBinding.Clang.Interop.CXModuleImpl q)
        {
            return new QBModule(){__Instance = q};
        }

    }

    ///<summary>
    /// A semantic string that describes a code-completion result.
    ///</summary>
    public partial class QBCompletionString
    {
        internal CXCompletionStringImpl __Instance;

        public QBCompletionString()
        {
        }

        public QBCompletionString(QuantumBinding.Clang.Interop.CXCompletionStringImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Retrieve the annotation associated with the given completion string.
        ///</summary>
        public CXString getCompletionAnnotation(uint annotation_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionAnnotation(this, annotation_number);
        }

        ///<summary>
        /// Determine the availability of the entity that this code-completion string refers to.
        ///</summary>
        public CXAvailabilityKind getCompletionAvailability()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionAvailability(this);
        }

        ///<summary>
        /// Retrieve the brief documentation comment attached to the declaration that corresponds to the given completion string.
        ///</summary>
        public CXString getCompletionBriefComment()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionBriefComment(this);
        }

        ///<summary>
        /// Retrieve the completion string associated with a particular chunk within a completion string.
        ///</summary>
        public QBCompletionString getCompletionChunkCompletionString(uint chunk_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionChunkCompletionString(this, chunk_number);
        }

        ///<summary>
        /// Determine the kind of a particular chunk within a completion string.
        ///</summary>
        public CXCompletionChunkKind getCompletionChunkKind(uint chunk_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionChunkKind(this, chunk_number);
        }

        ///<summary>
        /// Retrieve the text associated with a particular chunk within a completion string.
        ///</summary>
        public CXString getCompletionChunkText(uint chunk_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionChunkText(this, chunk_number);
        }

        ///<summary>
        /// Retrieve the number of annotations associated with the given completion string.
        ///</summary>
        public uint getCompletionNumAnnotations()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionNumAnnotations(this);
        }

        ///<summary>
        /// Retrieve the parent context of the given completion string.
        ///</summary>
        public CXString getCompletionParent(ref CXCursorKind kind)
        {
            var arg1 = (uint)kind;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionParent(this, ref arg1);
            kind = (CXCursorKind)arg1;
            return result;
        }

        ///<summary>
        /// Determine the priority of this code completion.
        ///</summary>
        public uint getCompletionPriority()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionPriority(this);
        }

        ///<summary>
        /// Retrieve the number of chunks in the given code-completion string.
        ///</summary>
        public uint getNumCompletionChunks()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumCompletionChunks(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXCompletionStringImpl(QBCompletionString q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXCompletionStringImpl();
        }

        public static implicit operator QBCompletionString(QuantumBinding.Clang.Interop.CXCompletionStringImpl q)
        {
            return new QBCompletionString(){__Instance = q};
        }

    }

    ///<summary>
    /// Evaluation result of a cursor
    ///</summary>
    public partial class QBEvalResult
    {
        internal CXEvalResultImpl __Instance;

        public QBEvalResult()
        {
        }

        public QBEvalResult(QuantumBinding.Clang.Interop.CXEvalResultImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Disposes the created Eval memory.
        ///</summary>
        public void EvalResult_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_dispose(this);
        }

        ///<summary>
        /// Returns the evaluation result as double if the kind is double.
        ///</summary>
        public double EvalResult_getAsDouble()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsDouble(this);
        }

        ///<summary>
        /// Returns the evaluation result as integer if the kind is Int.
        ///</summary>
        public int EvalResult_getAsInt()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsInt(this);
        }

        ///<summary>
        /// Returns the evaluation result as a long long integer if the kind is Int. This prevents overflows that may happen if the result is returned with clang_EvalResult_getAsInt.
        ///</summary>
        public long EvalResult_getAsLongLong()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsLongLong(this);
        }

        ///<summary>
        /// Returns the evaluation result as a constant string if the kind is other than Int or float. User must not free this pointer, instead call clang_EvalResult_dispose on the CXEvalResult returned by clang_Cursor_Evaluate.
        ///</summary>
        public string EvalResult_getAsStr()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsStr(this);
        }

        ///<summary>
        /// Returns the evaluation result as an unsigned integer if the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.
        ///</summary>
        public ulong EvalResult_getAsUnsigned()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsUnsigned(this);
        }

        ///<summary>
        /// Returns the kind of the evaluated result.
        ///</summary>
        public CXEvalResultKind EvalResult_getKind()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getKind(this);
        }

        ///<summary>
        /// Returns a non-zero value if the kind is Int and the evaluation result resulted in an unsigned integer.
        ///</summary>
        public uint EvalResult_isUnsignedInt()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_isUnsignedInt(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXEvalResultImpl(QBEvalResult q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXEvalResultImpl();
        }

        public static implicit operator QBEvalResult(QuantumBinding.Clang.Interop.CXEvalResultImpl q)
        {
            return new QBEvalResult(){__Instance = q};
        }

    }

    ///<summary>
    /// A remapping of original source files and their translated files.
    ///</summary>
    public partial class QBRemapping
    {
        internal CXRemappingImpl __Instance;

        public QBRemapping()
        {
        }

        public QBRemapping(QuantumBinding.Clang.Interop.CXRemappingImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Dispose the remapping.
        ///</summary>
        public void remap_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_remap_dispose(this);
        }

        ///<summary>
        /// Get the original and the associated filename from the remapping.
        ///</summary>
        public void remap_getFilenames(uint index, out QBString original, out QBString transformed)
        {
            CXString arg1;
            CXString arg2;
            QuantumBinding.Clang.Interop.ClangInterop.clang_remap_getFilenames(this, index, out arg1, out arg2);
            original = new QBString(arg1);
            transformed = new QBString(arg2);
        }

        ///<summary>
        /// Determine the number of remappings.
        ///</summary>
        public uint remap_getNumFiles()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_remap_getNumFiles(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXRemappingImpl(QBRemapping q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXRemappingImpl();
        }

        public static implicit operator QBRemapping(QuantumBinding.Clang.Interop.CXRemappingImpl q)
        {
            return new QBRemapping(){__Instance = q};
        }

    }

    ///<summary>
    /// The client's data object that is associated with a CXFile.
    ///</summary>
    public partial class QBIdxClientFile
    {
        internal CXIdxClientFileImpl __Instance;

        public QBIdxClientFile()
        {
        }

        public QBIdxClientFile(QuantumBinding.Clang.Interop.CXIdxClientFileImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIdxClientFileImpl(QBIdxClientFile q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIdxClientFileImpl();
        }

        public static implicit operator QBIdxClientFile(QuantumBinding.Clang.Interop.CXIdxClientFileImpl q)
        {
            return new QBIdxClientFile(){__Instance = q};
        }

    }

    ///<summary>
    /// The client's data object that is associated with a semantic entity.
    ///</summary>
    public partial class QBIdxClientEntity
    {
        internal CXIdxClientEntityImpl __Instance;

        public QBIdxClientEntity()
        {
        }

        public QBIdxClientEntity(QuantumBinding.Clang.Interop.CXIdxClientEntityImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIdxClientEntityImpl(QBIdxClientEntity q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIdxClientEntityImpl();
        }

        public static implicit operator QBIdxClientEntity(QuantumBinding.Clang.Interop.CXIdxClientEntityImpl q)
        {
            return new QBIdxClientEntity(){__Instance = q};
        }

    }

    ///<summary>
    /// The client's data object that is associated with a semantic container of entities.
    ///</summary>
    public partial class QBIdxClientContainer
    {
        internal CXIdxClientContainerImpl __Instance;

        public QBIdxClientContainer()
        {
        }

        public QBIdxClientContainer(QuantumBinding.Clang.Interop.CXIdxClientContainerImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIdxClientContainerImpl(QBIdxClientContainer q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIdxClientContainerImpl();
        }

        public static implicit operator QBIdxClientContainer(QuantumBinding.Clang.Interop.CXIdxClientContainerImpl q)
        {
            return new QBIdxClientContainer(){__Instance = q};
        }

    }

    ///<summary>
    /// The client's data object that is associated with an AST file (PCH or module).
    ///</summary>
    public partial class QBIdxClientASTFile
    {
        internal CXIdxClientASTFileImpl __Instance;

        public QBIdxClientASTFile()
        {
        }

        public QBIdxClientASTFile(QuantumBinding.Clang.Interop.CXIdxClientASTFileImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIdxClientASTFileImpl(QBIdxClientASTFile q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIdxClientASTFileImpl();
        }

        public static implicit operator QBIdxClientASTFile(QuantumBinding.Clang.Interop.CXIdxClientASTFileImpl q)
        {
            return new QBIdxClientASTFile(){__Instance = q};
        }

    }

    ///<summary>
    /// An indexing action/session, to be applied to one or multiple translation units.
    ///</summary>
    public partial class QBIndexAction
    {
        internal CXIndexActionImpl __Instance;

        public QBIndexAction()
        {
        }

        public QBIndexAction(QuantumBinding.Clang.Interop.CXIndexActionImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Destroy the given index action.
        ///</summary>
        public void IndexAction_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_IndexAction_dispose(this);
        }

        ///<summary>
        /// Index the given source file and the translation unit corresponding to that file via callbacks implemented through #IndexerCallbacks.
        ///</summary>
        public int indexSourceFile(QuantumBinding.Clang.QBClientData client_data, IndexerCallbacks index_callbacks, uint index_callbacks_size, uint index_options, string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile unsaved_files, uint num_unsaved_files, out QuantumBinding.Clang.QBTranslationUnit out_TU, uint TU_options)
        {
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            var arg2 = ReferenceEquals(index_callbacks, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(index_callbacks.ToInternal());
            var arg3 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            CXTranslationUnitImpl arg4;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexSourceFile(this, arg1, arg2, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, arg3, num_unsaved_files, out arg4, TU_options);
            index_callbacks?.Dispose();
            Marshal.FreeHGlobal(arg2);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg3);
            out_TU = new QBTranslationUnit(arg4);
            return result;
        }

        ///<summary>
        /// Same as clang_indexSourceFile but requires a full command line for command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.
        ///</summary>
        public int indexSourceFileFullArgv(QuantumBinding.Clang.QBClientData client_data, IndexerCallbacks index_callbacks, uint index_callbacks_size, uint index_options, string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile unsaved_files, uint num_unsaved_files, out QuantumBinding.Clang.QBTranslationUnit out_TU, uint TU_options)
        {
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            var arg2 = ReferenceEquals(index_callbacks, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(index_callbacks.ToInternal());
            var arg3 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            CXTranslationUnitImpl arg4;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexSourceFileFullArgv(this, arg1, arg2, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, arg3, num_unsaved_files, out arg4, TU_options);
            index_callbacks?.Dispose();
            Marshal.FreeHGlobal(arg2);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg3);
            out_TU = new QBTranslationUnit(arg4);
            return result;
        }

        ///<summary>
        /// Index the given translation unit via callbacks implemented through #IndexerCallbacks.
        ///</summary>
        public int indexTranslationUnit(QuantumBinding.Clang.QBClientData client_data, IndexerCallbacks index_callbacks, uint index_callbacks_size, uint index_options, QuantumBinding.Clang.QBTranslationUnit param5)
        {
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            var arg2 = ReferenceEquals(index_callbacks, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(index_callbacks.ToInternal());
            var arg3 = ReferenceEquals(param5, null) ? new CXTranslationUnitImpl() : (CXTranslationUnitImpl)param5;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexTranslationUnit(this, arg1, arg2, index_callbacks_size, index_options, arg3);
            index_callbacks?.Dispose();
            Marshal.FreeHGlobal(arg2);
            return result;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIndexActionImpl(QBIndexAction q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIndexActionImpl();
        }

        public static implicit operator QBIndexAction(QuantumBinding.Clang.Interop.CXIndexActionImpl q)
        {
            return new QBIndexAction(){__Instance = q};
        }

    }

    public static class clang
    {
        ///<summary>
        /// Retrieve the character data associated with the given string.
        ///</summary>
        public static string getCString(QBString @string)
        {
            var arg0 = ReferenceEquals(@string, null) ? new QuantumBinding.Clang.Interop.CXString() : @string.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCString(arg0);
            @string?.Dispose();
            return result;
        }

        ///<summary>
        /// Free the given string.
        ///</summary>
        public static void disposeString(QBString @string)
        {
            var arg0 = ReferenceEquals(@string, null) ? new QuantumBinding.Clang.Interop.CXString() : @string.ToInternal();
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeString(arg0);
            @string?.Dispose();
        }

        ///<summary>
        /// Free the given string set.
        ///</summary>
        public static void disposeStringSet(QBStringSet set)
        {
            var arg0 = ReferenceEquals(set, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(set.ToInternal());
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeStringSet(arg0);
            set?.Dispose();
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Return the timestamp for use with Clang's -fbuild-session-timestamp= option.
        ///</summary>
        public static ulong getBuildSessionTimestamp()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getBuildSessionTimestamp();
        }

        ///<summary>
        /// Create a CXVirtualFileOverlay object. Must be disposed with clang_VirtualFileOverlay_dispose().
        ///</summary>
        public static QBVirtualFileOverlay VirtualFileOverlay_create(uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_create(options);
        }

        ///<summary>
        /// free memory allocated by libclang, such as the buffer returned by CXVirtualFileOverlay() or clang_ModuleMapDescriptor_writeToBuffer().
        ///</summary>
        public static void free(ref System.IntPtr buffer)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_free(buffer);
        }

        ///<summary>
        /// Create a CXModuleMapDescriptor object. Must be disposed with clang_ModuleMapDescriptor_dispose().
        ///</summary>
        public static QBModuleMapDescriptor ModuleMapDescriptor_create(uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_create(options);
        }

        ///<summary>
        /// Provides a shared context for creating translation units.
        ///</summary>
        public static QBIndex createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_createIndex(excludeDeclarationsFromPCH, displayDiagnostics);
        }

        ///<summary>
        /// Retrieve a NULL (invalid) source location.
        ///</summary>
        public static CXSourceLocation getNullLocation()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNullLocation();
        }

        ///<summary>
        /// Determine whether two source locations, which must refer into the same translation unit, refer to exactly the same point in the source code.
        ///</summary>
        public static uint equalLocations(QBSourceLocation loc1, QBSourceLocation loc2)
        {
            var arg0 = ReferenceEquals(loc1, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : loc1.ToInternal();
            var arg1 = ReferenceEquals(loc2, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : loc2.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_equalLocations(arg0, arg1);
            return result;
        }

        ///<summary>
        /// Returns non-zero if the given source location is in a system header.
        ///</summary>
        public static int Location_isInSystemHeader(QBSourceLocation location)
        {
            var arg0 = ReferenceEquals(location, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : location.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Location_isInSystemHeader(arg0);
            return result;
        }

        ///<summary>
        /// Returns non-zero if the given source location is in the main file of the corresponding translation unit.
        ///</summary>
        public static int Location_isFromMainFile(QBSourceLocation location)
        {
            var arg0 = ReferenceEquals(location, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : location.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Location_isFromMainFile(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve a NULL (invalid) source range.
        ///</summary>
        public static CXSourceRange getNullRange()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNullRange();
        }

        ///<summary>
        /// Retrieve a source range given the beginning and ending source locations.
        ///</summary>
        public static CXSourceRange getRange(QBSourceLocation begin, QBSourceLocation end)
        {
            var arg0 = ReferenceEquals(begin, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : begin.ToInternal();
            var arg1 = ReferenceEquals(end, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : end.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getRange(arg0, arg1);
            return result;
        }

        ///<summary>
        /// Determine whether two ranges are equivalent.
        ///</summary>
        public static uint equalRanges(QBSourceRange range1, QBSourceRange range2)
        {
            var arg0 = ReferenceEquals(range1, null) ? new QuantumBinding.Clang.Interop.CXSourceRange() : range1.ToInternal();
            var arg1 = ReferenceEquals(range2, null) ? new QuantumBinding.Clang.Interop.CXSourceRange() : range2.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_equalRanges(arg0, arg1);
            return result;
        }

        ///<summary>
        /// Returns non-zero if range is null.
        ///</summary>
        public static int Range_isNull(QBSourceRange range)
        {
            var arg0 = ReferenceEquals(range, null) ? new QuantumBinding.Clang.Interop.CXSourceRange() : range.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Range_isNull(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the file, line, column, and offset represented by the given source location.
        ///</summary>
        public static void getExpansionLocation(QBSourceLocation location, out QuantumBinding.Clang.QBFile file, out uint line, out uint column, out uint offset)
        {
            var arg0 = ReferenceEquals(location, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : location.ToInternal();
            CXFileImpl arg1;
            QuantumBinding.Clang.Interop.ClangInterop.clang_getExpansionLocation(arg0, out arg1, out line, out column, out offset);
            file = new QBFile(arg1);
        }

        ///<summary>
        /// Retrieve the file, line and column represented by the given source location, as specified in a # line directive.
        ///</summary>
        public static void getPresumedLocation(QBSourceLocation location, out QBString filename, out uint line, out uint column)
        {
            var arg0 = ReferenceEquals(location, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : location.ToInternal();
            CXString arg1;
            QuantumBinding.Clang.Interop.ClangInterop.clang_getPresumedLocation(arg0, out arg1, out line, out column);
            filename = new QBString(arg1);
        }

        ///<summary>
        /// Legacy API to retrieve the file, line, column, and offset represented by the given source location.
        ///</summary>
        public static void getInstantiationLocation(QBSourceLocation location, out QuantumBinding.Clang.QBFile file, out uint line, out uint column, out uint offset)
        {
            var arg0 = ReferenceEquals(location, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : location.ToInternal();
            CXFileImpl arg1;
            QuantumBinding.Clang.Interop.ClangInterop.clang_getInstantiationLocation(arg0, out arg1, out line, out column, out offset);
            file = new QBFile(arg1);
        }

        ///<summary>
        /// Retrieve the file, line, column, and offset represented by the given source location.
        ///</summary>
        public static void getSpellingLocation(QBSourceLocation location, out QuantumBinding.Clang.QBFile file, out uint line, out uint column, out uint offset)
        {
            var arg0 = ReferenceEquals(location, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : location.ToInternal();
            CXFileImpl arg1;
            QuantumBinding.Clang.Interop.ClangInterop.clang_getSpellingLocation(arg0, out arg1, out line, out column, out offset);
            file = new QBFile(arg1);
        }

        ///<summary>
        /// Retrieve the file, line, column, and offset represented by the given source location.
        ///</summary>
        public static void getFileLocation(QBSourceLocation location, out QuantumBinding.Clang.QBFile file, out uint line, out uint column, out uint offset)
        {
            var arg0 = ReferenceEquals(location, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : location.ToInternal();
            CXFileImpl arg1;
            QuantumBinding.Clang.Interop.ClangInterop.clang_getFileLocation(arg0, out arg1, out line, out column, out offset);
            file = new QBFile(arg1);
        }

        ///<summary>
        /// Retrieve a source location representing the first character within a source range.
        ///</summary>
        public static CXSourceLocation getRangeStart(QBSourceRange range)
        {
            var arg0 = ReferenceEquals(range, null) ? new QuantumBinding.Clang.Interop.CXSourceRange() : range.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getRangeStart(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve a source location representing the last character within a source range.
        ///</summary>
        public static CXSourceLocation getRangeEnd(QBSourceRange range)
        {
            var arg0 = ReferenceEquals(range, null) ? new QuantumBinding.Clang.Interop.CXSourceRange() : range.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getRangeEnd(arg0);
            return result;
        }

        ///<summary>
        /// Destroy the given CXSourceRangeList.
        ///</summary>
        public static void disposeSourceRangeList(QBSourceRangeList ranges)
        {
            var arg0 = ReferenceEquals(ranges, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(ranges.ToInternal());
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeSourceRangeList(arg0);
            ranges?.Dispose();
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Deserialize a set of diagnostics from a Clang diagnostics bitcode file.
        ///</summary>
        public static QBDiagnosticSet loadDiagnostics(string file, out CXLoadDiag_Error error, out QBString errorString)
        {
            CXString arg1;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_loadDiagnostics(file, out error, out arg1);
            errorString = new QBString(arg1);
            return result;
        }

        ///<summary>
        /// Retrieve the set of display options most similar to the default behavior of the clang compiler.
        ///</summary>
        public static uint defaultDiagnosticDisplayOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultDiagnosticDisplayOptions();
        }

        ///<summary>
        /// Retrieve the name of a particular diagnostic category. This is now deprecated. Use clang_getDiagnosticCategoryText() instead.
        ///</summary>
        public static CXString getDiagnosticCategoryName(uint Category)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticCategoryName(Category);
        }

        ///<summary>
        /// Returns the set of flags that is suitable for parsing a translation unit that is being edited.
        ///</summary>
        public static uint defaultEditingTranslationUnitOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultEditingTranslationUnitOptions();
        }

        ///<summary>
        /// Returns the human-readable null-terminated C string that represents the name of the memory category. This string should never be freed.
        ///</summary>
        public static string getTUResourceUsageName(CXTUResourceUsageKind kind)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTUResourceUsageName(kind);
        }

        public static void disposeCXTUResourceUsage(QBTUResourceUsage usage)
        {
            var arg0 = ReferenceEquals(usage, null) ? new QuantumBinding.Clang.Interop.CXTUResourceUsage() : usage.ToInternal();
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeCXTUResourceUsage(arg0);
            usage?.Dispose();
        }

        ///<summary>
        /// Retrieve the NULL cursor, which represents no entity.
        ///</summary>
        public static CXCursor getNullCursor()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNullCursor();
        }

        ///<summary>
        /// Determine whether two cursors are equivalent.
        ///</summary>
        public static uint equalCursors(QBCursor param0, QBCursor param1)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var arg1 = ReferenceEquals(param1, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param1.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_equalCursors(arg0, arg1);
            return result;
        }

        ///<summary>
        /// Returns non-zero if cursor is null.
        ///</summary>
        public static int Cursor_isNull(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isNull(arg0);
            return result;
        }

        ///<summary>
        /// Compute a hash value for the given cursor.
        ///</summary>
        public static uint hashCursor(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_hashCursor(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the kind of the given cursor.
        ///</summary>
        public static CXCursorKind getCursorKind(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorKind(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a declaration.
        ///</summary>
        public static uint isDeclaration(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isDeclaration(param0);
        }

        ///<summary>
        /// Determine whether the given declaration is invalid.
        ///</summary>
        public static uint isInvalidDeclaration(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_isInvalidDeclaration(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a simple reference.
        ///</summary>
        public static uint isReference(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isReference(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents an expression.
        ///</summary>
        public static uint isExpression(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isExpression(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a statement.
        ///</summary>
        public static uint isStatement(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isStatement(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents an attribute.
        ///</summary>
        public static uint isAttribute(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isAttribute(param0);
        }

        ///<summary>
        /// Determine whether the given cursor has any attributes.
        ///</summary>
        public static uint Cursor_hasAttrs(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_hasAttrs(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether the given cursor kind represents an invalid cursor.
        ///</summary>
        public static uint isInvalid(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isInvalid(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a translation unit.
        ///</summary>
        public static uint isTranslationUnit(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isTranslationUnit(param0);
        }

        ///<summary>
        /// * Determine whether the given cursor represents a preprocessing element, such as a preprocessor directive or macro instantiation.
        ///</summary>
        public static uint isPreprocessing(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isPreprocessing(param0);
        }

        ///<summary>
        /// * Determine whether the given cursor represents a currently unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).
        ///</summary>
        public static uint isUnexposed(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isUnexposed(param0);
        }

        ///<summary>
        /// Determine the linkage of the entity referred to by a given cursor.
        ///</summary>
        public static CXLinkageKind getCursorLinkage(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorLinkage(arg0);
            return result;
        }

        ///<summary>
        /// Describe the visibility of the entity referred to by a cursor.
        ///</summary>
        public static CXVisibilityKind getCursorVisibility(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorVisibility(arg0);
            return result;
        }

        ///<summary>
        /// Determine the availability of the entity that this cursor refers to, taking the current target platform into account.
        ///</summary>
        public static CXAvailabilityKind getCursorAvailability(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorAvailability(arg0);
            return result;
        }

        ///<summary>
        /// Determine the availability of the entity that this cursor refers to on any platforms for which availability information is known.
        ///</summary>
        public static int getCursorPlatformAvailability(QBCursor cursor, int always_deprecated, QBString deprecated_message, ref int always_unavailable, QBString unavailable_message, QBPlatformAvailability[] availability, int availability_size)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var arg1 = ReferenceEquals(deprecated_message, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(deprecated_message.ToInternal());
            var arg2 = ReferenceEquals(unavailable_message, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unavailable_message.ToInternal());
            QuantumBinding.Clang.Interop.CXPlatformAvailability[] arg3 = null;
            arg3 = ReferenceEquals(availability, null) ? null : new QuantumBinding.Clang.Interop.CXPlatformAvailability[availability.Length];
            if (!ReferenceEquals(availability, null))
            {
                for (var i = 0U; i < availability.Length; ++i)
                {
                    arg3[i] = availability[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorPlatformAvailability(arg0, always_deprecated, arg1, ref always_unavailable, arg2, arg3, availability_size);
            deprecated_message?.Dispose();
            Marshal.FreeHGlobal(arg1);
            unavailable_message?.Dispose();
            Marshal.FreeHGlobal(arg2);
            return result;
        }

        ///<summary>
        /// Free the memory associated with a CXPlatformAvailability structure.
        ///</summary>
        public static void disposeCXPlatformAvailability(QBPlatformAvailability availability)
        {
            var arg0 = ReferenceEquals(availability, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(availability.ToInternal());
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeCXPlatformAvailability(arg0);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Determine the "language" of the entity referred to by a given cursor.
        ///</summary>
        public static CXLanguageKind getCursorLanguage(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorLanguage(arg0);
            return result;
        }

        ///<summary>
        /// Determine the "thread-local storage (TLS) kind" of the declaration referred to by a cursor.
        ///</summary>
        public static CXTLSKind getCursorTLSKind(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorTLSKind(arg0);
            return result;
        }

        ///<summary>
        /// Returns the translation unit that a cursor originated from.
        ///</summary>
        public static QBTranslationUnit Cursor_getTranslationUnit(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTranslationUnit(arg0);
            return result;
        }

        ///<summary>
        /// Determine the semantic parent of the given cursor.
        ///</summary>
        public static CXCursor getCursorSemanticParent(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorSemanticParent(arg0);
            return result;
        }

        ///<summary>
        /// Determine the lexical parent of the given cursor.
        ///</summary>
        public static CXCursor getCursorLexicalParent(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorLexicalParent(arg0);
            return result;
        }

        ///<summary>
        /// Determine the set of methods that are overridden by the given method.
        ///</summary>
        public static void getOverriddenCursors(QBCursor cursor, out QBCursor[] overridden, out uint num_overridden)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var arg1 = System.IntPtr.Zero;
            QuantumBinding.Clang.Interop.ClangInterop.clang_getOverriddenCursors(arg0, ref arg1, out num_overridden);
            var _overridden = new QuantumBinding.Clang.Interop.CXCursor[num_overridden];
            MarshalUtils.IntPtrToManagedArray<QuantumBinding.Clang.Interop.CXCursor>(arg1, _overridden);
            overridden = new QBCursor[num_overridden];
            for (var i = 0U; i< num_overridden; ++i)
            {
                overridden[i] = new QBCursor(_overridden[i]);
            }
        }

        ///<summary>
        /// Free the set of overridden cursors returned by clang_getOverriddenCursors().
        ///</summary>
        public static void disposeOverriddenCursors(QBCursor overridden)
        {
            var arg0 = ReferenceEquals(overridden, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(overridden.ToInternal());
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeOverriddenCursors(arg0);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Retrieve the file that is included by the given inclusion directive cursor.
        ///</summary>
        public static QBFile getIncludedFile(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getIncludedFile(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the physical location of the source constructor referenced by the given cursor.
        ///</summary>
        public static CXSourceLocation getCursorLocation(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorLocation(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the physical extent of the source construct referenced by the given cursor.
        ///</summary>
        public static CXSourceRange getCursorExtent(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorExtent(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the type of a CXCursor (if any).
        ///</summary>
        public static CXType getCursorType(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorType(arg0);
            return result;
        }

        ///<summary>
        /// Pretty-print the underlying type using the rules of the language of the translation unit from which it came.
        ///</summary>
        public static CXString getTypeSpelling(QBType CT)
        {
            var arg0 = ReferenceEquals(CT, null) ? new QuantumBinding.Clang.Interop.CXType() : CT.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTypeSpelling(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the underlying type of a typedef declaration.
        ///</summary>
        public static CXType getTypedefDeclUnderlyingType(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTypedefDeclUnderlyingType(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the integer type of an enum declaration.
        ///</summary>
        public static CXType getEnumDeclIntegerType(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getEnumDeclIntegerType(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the integer value of an enum constant declaration as a signed long long.
        ///</summary>
        public static long getEnumConstantDeclValue(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getEnumConstantDeclValue(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the integer value of an enum constant declaration as an unsigned long long.
        ///</summary>
        public static ulong getEnumConstantDeclUnsignedValue(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getEnumConstantDeclUnsignedValue(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the bit width of a bit field declaration as an integer.
        ///</summary>
        public static int getFieldDeclBitWidth(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getFieldDeclBitWidth(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the number of non-variadic arguments associated with a given cursor.
        ///</summary>
        public static int Cursor_getNumArguments(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getNumArguments(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the argument cursor of a function or method.
        ///</summary>
        public static CXCursor Cursor_getArgument(QBCursor C, uint i)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getArgument(arg0, i);
            return result;
        }

        ///<summary>
        /// Returns the number of template args of a function decl representing a template specialization.
        ///</summary>
        public static int Cursor_getNumTemplateArguments(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getNumTemplateArguments(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the kind of the I'th template argument of the CXCursor C.
        ///</summary>
        public static CXTemplateArgumentKind Cursor_getTemplateArgumentKind(QBCursor C, uint I)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTemplateArgumentKind(arg0, I);
            return result;
        }

        ///<summary>
        /// Retrieve a CXType representing the type of a TemplateArgument of a function decl representing a template specialization.
        ///</summary>
        public static CXType Cursor_getTemplateArgumentType(QBCursor C, uint I)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTemplateArgumentType(arg0, I);
            return result;
        }

        ///<summary>
        /// Retrieve the value of an Integral TemplateArgument (of a function decl representing a template specialization) as a signed long long.
        ///</summary>
        public static long Cursor_getTemplateArgumentValue(QBCursor C, uint I)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTemplateArgumentValue(arg0, I);
            return result;
        }

        ///<summary>
        /// Retrieve the value of an Integral TemplateArgument (of a function decl representing a template specialization) as an unsigned long long.
        ///</summary>
        public static ulong Cursor_getTemplateArgumentUnsignedValue(QBCursor C, uint I)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getTemplateArgumentUnsignedValue(arg0, I);
            return result;
        }

        ///<summary>
        /// Determine whether two CXTypes represent the same type.
        ///</summary>
        public static uint equalTypes(QBType A, QBType B)
        {
            var arg0 = ReferenceEquals(A, null) ? new QuantumBinding.Clang.Interop.CXType() : A.ToInternal();
            var arg1 = ReferenceEquals(B, null) ? new QuantumBinding.Clang.Interop.CXType() : B.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_equalTypes(arg0, arg1);
            return result;
        }

        ///<summary>
        /// Return the canonical type for a CXType.
        ///</summary>
        public static CXType getCanonicalType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCanonicalType(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether a CXType has the "const" qualifier set, without looking through typedefs that may have added "const" at a different level.
        ///</summary>
        public static uint isConstQualifiedType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_isConstQualifiedType(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether a CXCursor that is a macro, is function like.
        ///</summary>
        public static uint Cursor_isMacroFunctionLike(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isMacroFunctionLike(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether a CXCursor that is a macro, is a builtin one.
        ///</summary>
        public static uint Cursor_isMacroBuiltin(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isMacroBuiltin(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether a CXCursor that is a function declaration, is an inline declaration.
        ///</summary>
        public static uint Cursor_isFunctionInlined(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isFunctionInlined(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether a CXType has the "volatile" qualifier set, without looking through typedefs that may have added "volatile" at a different level.
        ///</summary>
        public static uint isVolatileQualifiedType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_isVolatileQualifiedType(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether a CXType has the "restrict" qualifier set, without looking through typedefs that may have added "restrict" at a different level.
        ///</summary>
        public static uint isRestrictQualifiedType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_isRestrictQualifiedType(arg0);
            return result;
        }

        ///<summary>
        /// Returns the address space of the given type.
        ///</summary>
        public static uint getAddressSpace(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getAddressSpace(arg0);
            return result;
        }

        ///<summary>
        /// Returns the typedef name of the given type.
        ///</summary>
        public static CXString getTypedefName(QBType CT)
        {
            var arg0 = ReferenceEquals(CT, null) ? new QuantumBinding.Clang.Interop.CXType() : CT.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTypedefName(arg0);
            return result;
        }

        ///<summary>
        /// For pointer types, returns the type of the pointee.
        ///</summary>
        public static CXType getPointeeType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getPointeeType(arg0);
            return result;
        }

        ///<summary>
        /// Return the cursor for the declaration of the given type.
        ///</summary>
        public static CXCursor getTypeDeclaration(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTypeDeclaration(arg0);
            return result;
        }

        ///<summary>
        /// Returns the Objective-C type encoding for the specified declaration.
        ///</summary>
        public static CXString getDeclObjCTypeEncoding(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getDeclObjCTypeEncoding(arg0);
            return result;
        }

        ///<summary>
        /// Returns the Objective-C type encoding for the specified CXType.
        ///</summary>
        public static CXString Type_getObjCEncoding(QBType type)
        {
            var arg0 = ReferenceEquals(type, null) ? new QuantumBinding.Clang.Interop.CXType() : type.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getObjCEncoding(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the spelling of a given CXTypeKind.
        ///</summary>
        public static CXString getTypeKindSpelling(CXTypeKind K)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTypeKindSpelling(K);
        }

        ///<summary>
        /// Retrieve the calling convention associated with a function type.
        ///</summary>
        public static CXCallingConv getFunctionTypeCallingConv(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getFunctionTypeCallingConv(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the return type associated with a function type.
        ///</summary>
        public static CXType getResultType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getResultType(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the exception specification type associated with a function type. This is a value of type CXCursor_ExceptionSpecificationKind.
        ///</summary>
        public static int getExceptionSpecificationType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getExceptionSpecificationType(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the number of non-variadic parameters associated with a function type.
        ///</summary>
        public static int getNumArgTypes(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getNumArgTypes(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the type of a parameter of a function type.
        ///</summary>
        public static CXType getArgType(QBType T, uint i)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getArgType(arg0, i);
            return result;
        }

        ///<summary>
        /// Retrieves the base type of the ObjCObjectType.
        ///</summary>
        public static CXType Type_getObjCObjectBaseType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getObjCObjectBaseType(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the number of protocol references associated with an ObjC object/id.
        ///</summary>
        public static uint Type_getNumObjCProtocolRefs(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNumObjCProtocolRefs(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the decl for a protocol reference for an ObjC object/id.
        ///</summary>
        public static CXCursor Type_getObjCProtocolDecl(QBType T, uint i)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getObjCProtocolDecl(arg0, i);
            return result;
        }

        ///<summary>
        /// Retreive the number of type arguments associated with an ObjC object.
        ///</summary>
        public static uint Type_getNumObjCTypeArgs(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNumObjCTypeArgs(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve a type argument associated with an ObjC object.
        ///</summary>
        public static CXType Type_getObjCTypeArg(QBType T, uint i)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getObjCTypeArg(arg0, i);
            return result;
        }

        ///<summary>
        /// Return 1 if the CXType is a variadic function type, and 0 otherwise.
        ///</summary>
        public static uint isFunctionTypeVariadic(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_isFunctionTypeVariadic(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the return type associated with a given cursor.
        ///</summary>
        public static CXType getCursorResultType(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorResultType(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the exception specification type associated with a given cursor. This is a value of type CXCursor_ExceptionSpecificationKind.
        ///</summary>
        public static int getCursorExceptionSpecificationType(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorExceptionSpecificationType(arg0);
            return result;
        }

        ///<summary>
        /// Return 1 if the CXType is a POD (plain old data) type, and 0 otherwise.
        ///</summary>
        public static uint isPODType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_isPODType(arg0);
            return result;
        }

        ///<summary>
        /// Return the element type of an array, complex, or vector type.
        ///</summary>
        public static CXType getElementType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getElementType(arg0);
            return result;
        }

        ///<summary>
        /// Return the number of elements of an array or vector type.
        ///</summary>
        public static long getNumElements(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getNumElements(arg0);
            return result;
        }

        ///<summary>
        /// Return the element type of an array type.
        ///</summary>
        public static CXType getArrayElementType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getArrayElementType(arg0);
            return result;
        }

        ///<summary>
        /// Return the array size of a constant array.
        ///</summary>
        public static long getArraySize(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getArraySize(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the type named by the qualified-id.
        ///</summary>
        public static CXType Type_getNamedType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNamedType(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a typedef is 'transparent' tag.
        ///</summary>
        public static uint Type_isTransparentTagTypedef(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_isTransparentTagTypedef(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the nullability kind of a pointer type.
        ///</summary>
        public static CXTypeNullabilityKind Type_getNullability(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNullability(arg0);
            return result;
        }

        ///<summary>
        /// Return the alignment of a type in bytes as per C++[expr.alignof] standard.
        ///</summary>
        public static long Type_getAlignOf(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getAlignOf(arg0);
            return result;
        }

        ///<summary>
        /// Return the class type of an member pointer type.
        ///</summary>
        public static CXType Type_getClassType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getClassType(arg0);
            return result;
        }

        ///<summary>
        /// Return the size of a type in bytes as per C++[expr.sizeof] standard.
        ///</summary>
        public static long Type_getSizeOf(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getSizeOf(arg0);
            return result;
        }

        ///<summary>
        /// Return the offset of a field named S in a record of type T in bits as it would be returned by __offsetof__ as per C++11[18.2p4]
        ///</summary>
        public static long Type_getOffsetOf(QBType T, string S)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getOffsetOf(arg0, S);
            return result;
        }

        ///<summary>
        /// Return the type that was modified by this attributed type.
        ///</summary>
        public static CXType Type_getModifiedType(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getModifiedType(arg0);
            return result;
        }

        ///<summary>
        /// Return the offset of the field represented by the Cursor.
        ///</summary>
        public static long Cursor_getOffsetOfField(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getOffsetOfField(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether the given cursor represents an anonymous record declaration.
        ///</summary>
        public static uint Cursor_isAnonymous(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isAnonymous(arg0);
            return result;
        }

        ///<summary>
        /// Returns the number of template arguments for given template specialization, or -1 if type T is not a template specialization.
        ///</summary>
        public static int Type_getNumTemplateArguments(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getNumTemplateArguments(arg0);
            return result;
        }

        ///<summary>
        /// Returns the type template argument of a template class specialization at given index.
        ///</summary>
        public static CXType Type_getTemplateArgumentAsType(QBType T, uint i)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getTemplateArgumentAsType(arg0, i);
            return result;
        }

        ///<summary>
        /// Retrieve the ref-qualifier kind of a function or method.
        ///</summary>
        public static CXRefQualifierKind Type_getCXXRefQualifier(QBType T)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_getCXXRefQualifier(arg0);
            return result;
        }

        ///<summary>
        /// Returns non-zero if the cursor specifies a Record member that is a bitfield.
        ///</summary>
        public static uint Cursor_isBitField(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isBitField(arg0);
            return result;
        }

        ///<summary>
        /// Returns 1 if the base class specified by the cursor with kind CX_CXXBaseSpecifier is virtual.
        ///</summary>
        public static uint isVirtualBase(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_isVirtualBase(arg0);
            return result;
        }

        ///<summary>
        /// Returns the access control level for the referenced object.
        ///</summary>
        public static CX_CXXAccessSpecifier getCXXAccessSpecifier(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCXXAccessSpecifier(arg0);
            return result;
        }

        ///<summary>
        /// Returns the storage class for a function or variable declaration.
        ///</summary>
        public static CX_StorageClass Cursor_getStorageClass(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getStorageClass(arg0);
            return result;
        }

        ///<summary>
        /// Determine the number of overloaded declarations referenced by a CXCursor_OverloadedDeclRef cursor.
        ///</summary>
        public static uint getNumOverloadedDecls(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getNumOverloadedDecls(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve a cursor for one of the overloaded declarations referenced by a CXCursor_OverloadedDeclRef cursor.
        ///</summary>
        public static CXCursor getOverloadedDecl(QBCursor cursor, uint index)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getOverloadedDecl(arg0, index);
            return result;
        }

        ///<summary>
        /// For cursors representing an iboutletcollection attribute, this function returns the collection element type.
        ///</summary>
        public static CXType getIBOutletCollectionType(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getIBOutletCollectionType(arg0);
            return result;
        }

        ///<summary>
        /// Visit the children of a particular cursor.
        ///</summary>
        public static uint visitChildren(QBCursor parent, System.IntPtr visitor, QuantumBinding.Clang.QBClientData client_data)
        {
            var arg0 = ReferenceEquals(parent, null) ? new QuantumBinding.Clang.Interop.CXCursor() : parent.ToInternal();
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_visitChildren(arg0, visitor, arg1);
            return result;
        }

        ///<summary>
        /// Retrieve a Unified Symbol Resolution (USR) for the entity referenced by the given cursor.
        ///</summary>
        public static CXString getCursorUSR(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorUSR(arg0);
            return result;
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C class.
        ///</summary>
        public static CXString constructUSR_ObjCClass(string class_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCClass(class_name);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C category.
        ///</summary>
        public static CXString constructUSR_ObjCCategory(string class_name, string category_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCCategory(class_name, category_name);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C protocol.
        ///</summary>
        public static CXString constructUSR_ObjCProtocol(string protocol_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCProtocol(protocol_name);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C instance variable and the USR for its containing class.
        ///</summary>
        public static CXString constructUSR_ObjCIvar(string name, QBString classUSR)
        {
            var arg0 = ReferenceEquals(classUSR, null) ? new QuantumBinding.Clang.Interop.CXString() : classUSR.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCIvar(name, arg0);
            classUSR?.Dispose();
            return result;
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C method and the USR for its containing class.
        ///</summary>
        public static CXString constructUSR_ObjCMethod(string name, uint isInstanceMethod, QBString classUSR)
        {
            var arg0 = ReferenceEquals(classUSR, null) ? new QuantumBinding.Clang.Interop.CXString() : classUSR.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCMethod(name, isInstanceMethod, arg0);
            classUSR?.Dispose();
            return result;
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C property and the USR for its containing class.
        ///</summary>
        public static CXString constructUSR_ObjCProperty(string property, QBString classUSR)
        {
            var arg0 = ReferenceEquals(classUSR, null) ? new QuantumBinding.Clang.Interop.CXString() : classUSR.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCProperty(property, arg0);
            classUSR?.Dispose();
            return result;
        }

        ///<summary>
        /// Retrieve a name for the entity referenced by this cursor.
        ///</summary>
        public static CXString getCursorSpelling(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorSpelling(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve a range for a piece that forms the cursors spelling name. Most of the times there is only one range for the complete spelling but for Objective-C methods and Objective-C message expressions, there are multiple pieces for each selector identifier.
        ///</summary>
        public static CXSourceRange Cursor_getSpellingNameRange(QBCursor param0, uint pieceIndex, uint options)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getSpellingNameRange(arg0, pieceIndex, options);
            return result;
        }

        ///<summary>
        /// Retrieve the default policy for the cursor.
        ///</summary>
        public static QBPrintingPolicy getCursorPrintingPolicy(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorPrintingPolicy(arg0);
            return result;
        }

        ///<summary>
        /// Pretty print declarations.
        ///</summary>
        public static CXString getCursorPrettyPrinted(QBCursor Cursor, QuantumBinding.Clang.QBPrintingPolicy Policy)
        {
            var arg0 = ReferenceEquals(Cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : Cursor.ToInternal();
            var arg1 = ReferenceEquals(Policy, null) ? new CXPrintingPolicyImpl() : (CXPrintingPolicyImpl)Policy;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorPrettyPrinted(arg0, arg1);
            return result;
        }

        ///<summary>
        /// Retrieve the display name for the entity referenced by this cursor.
        ///</summary>
        public static CXString getCursorDisplayName(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorDisplayName(arg0);
            return result;
        }

        ///<summary>
        /// For a cursor that is a reference, retrieve a cursor representing the entity that it references.
        ///</summary>
        public static CXCursor getCursorReferenced(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorReferenced(arg0);
            return result;
        }

        ///<summary>
        /// For a cursor that is either a reference to or a declaration of some entity, retrieve a cursor that describes the definition of that entity.
        ///</summary>
        public static CXCursor getCursorDefinition(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorDefinition(arg0);
            return result;
        }

        ///<summary>
        /// Determine whether the declaration pointed to by this cursor is also a definition of that entity.
        ///</summary>
        public static uint isCursorDefinition(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_isCursorDefinition(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the canonical cursor corresponding to the given cursor.
        ///</summary>
        public static CXCursor getCanonicalCursor(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCanonicalCursor(arg0);
            return result;
        }

        ///<summary>
        /// If the cursor points to a selector identifier in an Objective-C method or message expression, this returns the selector index.
        ///</summary>
        public static int Cursor_getObjCSelectorIndex(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCSelectorIndex(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor pointing to a C++ method call or an Objective-C message, returns non-zero if the method/message is "dynamic", meaning:
        ///</summary>
        public static int Cursor_isDynamicCall(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isDynamicCall(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor pointing to an Objective-C message or property reference, or C++ method call, returns the CXType of the receiver.
        ///</summary>
        public static CXType Cursor_getReceiverType(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getReceiverType(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents a property declaration, return the associated property attributes. The bits are formed from CXObjCPropertyAttrKind.
        ///</summary>
        public static uint Cursor_getObjCPropertyAttributes(QBCursor C, uint reserved)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCPropertyAttributes(arg0, reserved);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents a property declaration, return the name of the method that implements the getter.
        ///</summary>
        public static CXString Cursor_getObjCPropertyGetterName(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCPropertyGetterName(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents a property declaration, return the name of the method that implements the setter, if any.
        ///</summary>
        public static CXString Cursor_getObjCPropertySetterName(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCPropertySetterName(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents an Objective-C method or parameter declaration, return the associated Objective-C qualifiers for the return type or the parameter respectively. The bits are formed from CXObjCDeclQualifierKind.
        ///</summary>
        public static uint Cursor_getObjCDeclQualifiers(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCDeclQualifiers(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents an Objective-C method or property declaration, return non-zero if the declaration was affected by "@optional". Returns zero if the cursor is not such a declaration or it is "@required".
        ///</summary>
        public static uint Cursor_isObjCOptional(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isObjCOptional(arg0);
            return result;
        }

        ///<summary>
        /// Returns non-zero if the given cursor is a variadic function or method.
        ///</summary>
        public static uint Cursor_isVariadic(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isVariadic(arg0);
            return result;
        }

        ///<summary>
        /// Returns non-zero if the given cursor points to a symbol marked with external_source_symbol attribute.
        ///</summary>
        public static uint Cursor_isExternalSymbol(QBCursor C, QBString language, QBString definedIn, ref uint isGenerated)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var arg1 = ReferenceEquals(language, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(language.ToInternal());
            var arg2 = ReferenceEquals(definedIn, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(definedIn.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_isExternalSymbol(arg0, arg1, arg2, ref isGenerated);
            language?.Dispose();
            Marshal.FreeHGlobal(arg1);
            definedIn?.Dispose();
            Marshal.FreeHGlobal(arg2);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents a declaration, return the associated comment's source range. The range may include multiple consecutive comments with whitespace in between.
        ///</summary>
        public static CXSourceRange Cursor_getCommentRange(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getCommentRange(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents a declaration, return the associated comment text, including comment markers.
        ///</summary>
        public static CXString Cursor_getRawCommentText(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getRawCommentText(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents a documentable entity (e.g., declaration), return the associated first paragraph.
        ///</summary>
        public static CXString Cursor_getBriefCommentText(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getBriefCommentText(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the CXString representing the mangled name of the cursor.
        ///</summary>
        public static CXString Cursor_getMangling(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getMangling(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the CXStrings representing the mangled symbols of the C++ constructor or destructor at the cursor.
        ///</summary>
        public static CXStringSet Cursor_getCXXManglings(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getCXXManglings(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the CXStrings representing the mangled symbols of the ObjC class interface or implementation at the cursor.
        ///</summary>
        public static CXStringSet Cursor_getObjCManglings(QBCursor param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getObjCManglings(arg0);
            return result;
        }

        ///<summary>
        /// Given a CXCursor_ModuleImportDecl cursor, return the associated module.
        ///</summary>
        public static QBModule Cursor_getModule(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getModule(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ constructor is a converting constructor.
        ///</summary>
        public static uint CXXConstructor_isConvertingConstructor(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXConstructor_isConvertingConstructor(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ constructor is a copy constructor.
        ///</summary>
        public static uint CXXConstructor_isCopyConstructor(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXConstructor_isCopyConstructor(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ constructor is the default constructor.
        ///</summary>
        public static uint CXXConstructor_isDefaultConstructor(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXConstructor_isDefaultConstructor(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ constructor is a move constructor.
        ///</summary>
        public static uint CXXConstructor_isMoveConstructor(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXConstructor_isMoveConstructor(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ field is declared 'mutable'.
        ///</summary>
        public static uint CXXField_isMutable(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXField_isMutable(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ method is declared '= default'.
        ///</summary>
        public static uint CXXMethod_isDefaulted(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isDefaulted(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ member function or member function template is pure virtual.
        ///</summary>
        public static uint CXXMethod_isPureVirtual(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isPureVirtual(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ member function or member function template is declared 'static'.
        ///</summary>
        public static uint CXXMethod_isStatic(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isStatic(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ member function or member function template is explicitly declared 'virtual' or if it overrides a virtual method from one of the base classes.
        ///</summary>
        public static uint CXXMethod_isVirtual(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isVirtual(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ record is abstract, i.e. whether a class or struct has a pure virtual member function.
        ///</summary>
        public static uint CXXRecord_isAbstract(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXRecord_isAbstract(arg0);
            return result;
        }

        ///<summary>
        /// Determine if an enum declaration refers to a scoped enum.
        ///</summary>
        public static uint EnumDecl_isScoped(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_EnumDecl_isScoped(arg0);
            return result;
        }

        ///<summary>
        /// Determine if a C++ member function or member function template is declared 'const'.
        ///</summary>
        public static uint CXXMethod_isConst(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXXMethod_isConst(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents a template, determine the cursor kind of the specializations would be generated by instantiating the template.
        ///</summary>
        public static CXCursorKind getTemplateCursorKind(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTemplateCursorKind(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor that may represent a specialization or instantiation of a template, retrieve the cursor that represents the template that it specializes or from which it was instantiated.
        ///</summary>
        public static CXCursor getSpecializedCursorTemplate(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getSpecializedCursorTemplate(arg0);
            return result;
        }

        ///<summary>
        /// Given a cursor that references something else, return the source range covering that reference.
        ///</summary>
        public static CXSourceRange getCursorReferenceNameRange(QBCursor C, uint NameFlags, uint PieceIndex)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorReferenceNameRange(arg0, NameFlags, PieceIndex);
            return result;
        }

        ///<summary>
        /// Determine the kind of the given token.
        ///</summary>
        public static CXTokenKind getTokenKind(QBToken param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXToken() : param0.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenKind(arg0);
            param0?.Dispose();
            return result;
        }

        ///<summary>
        /// for debug/testing
        ///</summary>
        public static CXString getCursorKindSpelling(CXCursorKind Kind)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorKindSpelling(Kind);
        }

        public static void getDefinitionSpellingAndExtent(QBCursor param0, in string[] startBuf, in string[] endBuf, ref uint startLine, ref uint startColumn, ref uint endLine, ref uint endColumn)
        {
            var arg0 = ReferenceEquals(param0, null) ? new QuantumBinding.Clang.Interop.CXCursor() : param0.ToInternal();
            QuantumBinding.Clang.Interop.ClangInterop.clang_getDefinitionSpellingAndExtent(arg0, startBuf, endBuf, ref startLine, ref startColumn, ref endLine, ref endColumn);
        }

        public static void enableStackTraces()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_enableStackTraces();
        }

        public static void executeOnThread(System.IntPtr fn, ref System.IntPtr user_data, uint stack_size)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_executeOnThread(fn, user_data, stack_size);
        }

        ///<summary>
        /// Retrieve a completion string for an arbitrary declaration or macro definition cursor.
        ///</summary>
        public static QBCompletionString getCursorCompletionString(QBCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorCompletionString(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve the number of fix-its for the given completion index.
        ///</summary>
        public static uint getCompletionNumFixIts(QBCodeCompleteResults results, uint completion_index)
        {
            var arg0 = ReferenceEquals(results, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(results.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionNumFixIts(arg0, completion_index);
            results?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// Fix-its that *must* be applied before inserting the text for the corresponding completion.
        ///</summary>
        public static CXString getCompletionFixIt(QBCodeCompleteResults results, uint completion_index, uint fixit_index, QBSourceRange replacement_range)
        {
            var arg0 = ReferenceEquals(results, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(results.ToInternal());
            var arg1 = ReferenceEquals(replacement_range, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(replacement_range.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionFixIt(arg0, completion_index, fixit_index, arg1);
            results?.Dispose();
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Returns a default set of code-completion options that can be passed to clang_codeCompleteAt().
        ///</summary>
        public static uint defaultCodeCompleteOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultCodeCompleteOptions();
        }

        ///<summary>
        /// Sort the code-completion results in case-insensitive alphabetical order.
        ///</summary>
        public static void sortCodeCompletionResults(QBCodeCompleteResults[] Results, uint NumResults)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            QuantumBinding.Clang.Interop.ClangInterop.clang_sortCodeCompletionResults(arg0, NumResults);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
        }

        ///<summary>
        /// Free the given set of code-completion results.
        ///</summary>
        public static void disposeCodeCompleteResults(QBCodeCompleteResults Results)
        {
            var arg0 = ReferenceEquals(Results, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(Results.ToInternal());
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeCodeCompleteResults(arg0);
            Results?.Dispose();
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Determine the number of diagnostics produced prior to the location where code completion was performed.
        ///</summary>
        public static uint codeCompleteGetNumDiagnostics(QBCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetNumDiagnostics(arg0);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Retrieve a diagnostic associated with the given code completion.
        ///</summary>
        public static QBDiagnostic codeCompleteGetDiagnostic(QBCodeCompleteResults[] Results, uint Index)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetDiagnostic(arg0, Index);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Determines what completions are appropriate for the context the given code completion.
        ///</summary>
        public static ulong codeCompleteGetContexts(QBCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetContexts(arg0);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Returns the cursor kind for the container for the current code completion context. The container is only guaranteed to be set for contexts where a container exists (i.e. member accesses or Objective-C message sends); if there is not a container, this function will return CXCursor_InvalidCode.
        ///</summary>
        public static CXCursorKind codeCompleteGetContainerKind(QBCodeCompleteResults[] Results, out uint IsIncomplete)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetContainerKind(arg0, out IsIncomplete);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Returns the USR for the container for the current code completion context. If there is not a container for the current context, this function will return the empty string.
        ///</summary>
        public static CXString codeCompleteGetContainerUSR(QBCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetContainerUSR(arg0);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Returns the currently-entered selector for an Objective-C message send, formatted like "initWithFoo:bar:". Only guaranteed to return a non-empty string for CXCompletionContext_ObjCInstanceMessage and CXCompletionContext_ObjCClassMessage.
        ///</summary>
        public static CXString codeCompleteGetObjCSelector(QBCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetObjCSelector(arg0);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Return a version string, suitable for showing to a user, but not intended to be parsed (the format is not guaranteed to be stable).
        ///</summary>
        public static CXString getClangVersion()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getClangVersion();
        }

        ///<summary>
        /// Enable/disable crash recovery.
        ///</summary>
        public static void toggleCrashRecovery(uint isEnabled)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_toggleCrashRecovery(isEnabled);
        }

        ///<summary>
        /// If cursor is a statement declaration tries to evaluate the statement and if its variable, tries to evaluate its initializer, into its corresponding type.
        ///</summary>
        public static QBEvalResult Cursor_Evaluate(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_Evaluate(arg0);
            return result;
        }

        ///<summary>
        /// Retrieve a remapping.
        ///</summary>
        public static QBRemapping getRemappings(string path)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getRemappings(path);
        }

        ///<summary>
        /// Retrieve a remapping.
        ///</summary>
        public static QBRemapping getRemappingsFromFileList(in string[] filePaths, uint numFiles)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getRemappingsFromFileList(filePaths, numFiles);
        }

        ///<summary>
        /// Find references of a declaration in a specific file.
        ///</summary>
        public static CXResult findReferencesInFile(QBCursor cursor, QuantumBinding.Clang.QBFile file, QBCursorAndRangeVisitor visitor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            var arg2 = ReferenceEquals(visitor, null) ? new QuantumBinding.Clang.Interop.CXCursorAndRangeVisitor() : visitor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_findReferencesInFile(arg0, arg1, arg2);
            visitor?.Dispose();
            return result;
        }

        public static int index_isEntityObjCContainerKind(CXIdxEntityKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_index_isEntityObjCContainerKind(param0);
        }

        public static CXIdxObjCContainerDeclInfo index_getObjCContainerDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCContainerDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxObjCInterfaceDeclInfo index_getObjCInterfaceDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCInterfaceDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxObjCCategoryDeclInfo index_getObjCCategoryDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCCategoryDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxObjCProtocolRefListInfo index_getObjCProtocolRefListInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCProtocolRefListInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxObjCPropertyDeclInfo index_getObjCPropertyDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCPropertyDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxIBOutletCollectionAttrInfo index_getIBOutletCollectionAttrInfo(in QBIdxAttrInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getIBOutletCollectionAttrInfo(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static CXIdxCXXClassDeclInfo index_getCXXClassDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getCXXClassDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// For retrieving a custom CXIdxClientContainer attached to a container.
        ///</summary>
        public static QBIdxClientContainer index_getClientContainer(in QBIdxContainerInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getClientContainer(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// For setting a custom CXIdxClientContainer attached to a container.
        ///</summary>
        public static void index_setClientContainer(in QBIdxContainerInfo param0, QuantumBinding.Clang.QBIdxClientContainer param1)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var arg1 = ReferenceEquals(param1, null) ? new CXIdxClientContainerImpl() : (CXIdxClientContainerImpl)param1;
            QuantumBinding.Clang.Interop.ClangInterop.clang_index_setClientContainer(arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// For retrieving a custom CXIdxClientEntity attached to an entity.
        ///</summary>
        public static QBIdxClientEntity index_getClientEntity(in QBIdxEntityInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getClientEntity(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// For setting a custom CXIdxClientEntity attached to an entity.
        ///</summary>
        public static void index_setClientEntity(in QBIdxEntityInfo param0, QuantumBinding.Clang.QBIdxClientEntity param1)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var arg1 = ReferenceEquals(param1, null) ? new CXIdxClientEntityImpl() : (CXIdxClientEntityImpl)param1;
            QuantumBinding.Clang.Interop.ClangInterop.clang_index_setClientEntity(arg0, arg1);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// Retrieve the CXIdxFile, file, line, column, and offset represented by the given CXIdxLoc.
        ///</summary>
        public static void indexLoc_getFileLocation(QBIdxLoc loc, out QuantumBinding.Clang.QBIdxClientFile indexFile, out QuantumBinding.Clang.QBFile file, out uint line, out uint column, out uint offset)
        {
            var arg0 = ReferenceEquals(loc, null) ? new QuantumBinding.Clang.Interop.CXIdxLoc() : loc.ToInternal();
            CXIdxClientFileImpl arg1;
            CXFileImpl arg2;
            QuantumBinding.Clang.Interop.ClangInterop.clang_indexLoc_getFileLocation(arg0, out arg1, out arg2, out line, out column, out offset);
            indexFile = new QBIdxClientFile(arg1);
            file = new QBFile(arg2);
        }

        ///<summary>
        /// Retrieve the CXSourceLocation represented by the given CXIdxLoc.
        ///</summary>
        public static CXSourceLocation indexLoc_getCXSourceLocation(QBIdxLoc loc)
        {
            var arg0 = ReferenceEquals(loc, null) ? new QuantumBinding.Clang.Interop.CXIdxLoc() : loc.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexLoc_getCXSourceLocation(arg0);
            return result;
        }

        ///<summary>
        /// Visit the fields of a particular type.
        ///</summary>
        public static uint Type_visitFields(QBType T, System.IntPtr visitor, QuantumBinding.Clang.QBClientData client_data)
        {
            var arg0 = ReferenceEquals(T, null) ? new QuantumBinding.Clang.Interop.CXType() : T.ToInternal();
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Type_visitFields(arg0, visitor, arg1);
            return result;
        }

        ///<summary>
        /// Given a cursor that represents a documentable entity (e.g., declaration), return the associated parsed comment as a CXComment_FullComment AST node.
        ///</summary>
        public static CXComment Cursor_getParsedComment(QBCursor C)
        {
            var arg0 = ReferenceEquals(C, null) ? new QuantumBinding.Clang.Interop.CXCursor() : C.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Cursor_getParsedComment(arg0);
            return result;
        }

        ///<summary>
        /// Returns the type of the AST node.
        ///</summary>
        public static CXCommentKind Comment_getKind(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Comment_getKind(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns number of children of the AST node.
        ///</summary>
        public static uint Comment_getNumChildren(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Comment_getNumChildren(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns the specified child of the AST node.
        ///</summary>
        public static CXComment Comment_getChild(QBComment Comment, uint ChildIdx)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Comment_getChild(arg0, ChildIdx);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// A CXComment_Paragraph node is considered whitespace if it contains only CXComment_Text nodes that are empty or whitespace.
        ///</summary>
        public static uint Comment_isWhitespace(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_Comment_isWhitespace(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns non-zero if Comment is inline content and has a newline immediately following it in the comment text. Newlines between paragraphs do not count.
        ///</summary>
        public static uint InlineContentComment_hasTrailingNewline(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_InlineContentComment_hasTrailingNewline(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns text contained in the AST node.
        ///</summary>
        public static CXString TextComment_getText(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_TextComment_getText(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns name of the inline command.
        ///</summary>
        public static CXString InlineCommandComment_getCommandName(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_InlineCommandComment_getCommandName(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns the most appropriate rendering mode, chosen on command semantics in Doxygen.
        ///</summary>
        public static CXCommentInlineCommandRenderKind InlineCommandComment_getRenderKind(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_InlineCommandComment_getRenderKind(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns number of command arguments.
        ///</summary>
        public static uint InlineCommandComment_getNumArgs(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_InlineCommandComment_getNumArgs(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns text of the specified argument.
        ///</summary>
        public static CXString InlineCommandComment_getArgText(QBComment Comment, uint ArgIdx)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_InlineCommandComment_getArgText(arg0, ArgIdx);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns HTML tag name.
        ///</summary>
        public static CXString HTMLTagComment_getTagName(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLTagComment_getTagName(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns non-zero if tag is self-closing (for example, <br />).
        ///</summary>
        public static uint HTMLStartTagComment_isSelfClosing(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLStartTagComment_isSelfClosing(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns number of attributes (name-value pairs) attached to the start tag.
        ///</summary>
        public static uint HTMLStartTag_getNumAttrs(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLStartTag_getNumAttrs(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns name of the specified attribute.
        ///</summary>
        public static CXString HTMLStartTag_getAttrName(QBComment Comment, uint AttrIdx)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLStartTag_getAttrName(arg0, AttrIdx);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns value of the specified attribute.
        ///</summary>
        public static CXString HTMLStartTag_getAttrValue(QBComment Comment, uint AttrIdx)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLStartTag_getAttrValue(arg0, AttrIdx);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns name of the block command.
        ///</summary>
        public static CXString BlockCommandComment_getCommandName(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_BlockCommandComment_getCommandName(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns number of word-like arguments.
        ///</summary>
        public static uint BlockCommandComment_getNumArgs(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_BlockCommandComment_getNumArgs(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns text of the specified word-like argument.
        ///</summary>
        public static CXString BlockCommandComment_getArgText(QBComment Comment, uint ArgIdx)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_BlockCommandComment_getArgText(arg0, ArgIdx);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns paragraph argument of the block command.
        ///</summary>
        public static CXComment BlockCommandComment_getParagraph(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_BlockCommandComment_getParagraph(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns parameter name.
        ///</summary>
        public static CXString ParamCommandComment_getParamName(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_getParamName(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns non-zero if the parameter that this AST node represents was found in the function prototype and clang_ParamCommandComment_getParamIndex function will return a meaningful value.
        ///</summary>
        public static uint ParamCommandComment_isParamIndexValid(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_isParamIndexValid(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns zero-based parameter index in function prototype.
        ///</summary>
        public static uint ParamCommandComment_getParamIndex(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_getParamIndex(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns non-zero if parameter passing direction was specified explicitly in the comment.
        ///</summary>
        public static uint ParamCommandComment_isDirectionExplicit(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_isDirectionExplicit(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns parameter passing direction.
        ///</summary>
        public static CXCommentParamPassDirection ParamCommandComment_getDirection(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_ParamCommandComment_getDirection(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns template parameter name.
        ///</summary>
        public static CXString TParamCommandComment_getParamName(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_TParamCommandComment_getParamName(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns non-zero if the parameter that this AST node represents was found in the template parameter list and clang_TParamCommandComment_getDepth and clang_TParamCommandComment_getIndex functions will return a meaningful value.
        ///</summary>
        public static uint TParamCommandComment_isParamPositionValid(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_TParamCommandComment_isParamPositionValid(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns zero-based nesting depth of this parameter in the template parameter list.
        ///</summary>
        public static uint TParamCommandComment_getDepth(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_TParamCommandComment_getDepth(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns zero-based parameter index in the template parameter list at a given nesting depth.
        ///</summary>
        public static uint TParamCommandComment_getIndex(QBComment Comment, uint Depth)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_TParamCommandComment_getIndex(arg0, Depth);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns text contained in the AST node.
        ///</summary>
        public static CXString VerbatimBlockLineComment_getText(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_VerbatimBlockLineComment_getText(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Returns text contained in the AST node.
        ///</summary>
        public static CXString VerbatimLineComment_getText(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_VerbatimLineComment_getText(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Convert an HTML tag AST node to string.
        ///</summary>
        public static CXString HTMLTagComment_getAsString(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_HTMLTagComment_getAsString(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Convert a given full parsed comment to an HTML fragment.
        ///</summary>
        public static CXString FullComment_getAsHTML(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_FullComment_getAsHTML(arg0);
            Comment?.Dispose();
            return result;
        }

        ///<summary>
        /// Convert a given full parsed comment to an XML document.
        ///</summary>
        public static CXString FullComment_getAsXML(QBComment Comment)
        {
            var arg0 = ReferenceEquals(Comment, null) ? new QuantumBinding.Clang.Interop.CXComment() : Comment.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_FullComment_getAsXML(arg0);
            Comment?.Dispose();
            return result;
        }

    }

}

