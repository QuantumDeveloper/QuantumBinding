// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

namespace QuantumBinding.Clang
{
    using System;
    using System.Runtime.InteropServices;
    using QuantumBinding.Clang.Interop;

    ///<summary>
    /// Object encapsulating information about overlaying virtual file/directories over the real file system.
    ///</summary>
    public partial class QBVirtualFileOverlay
    {
        internal CXVirtualFileOverlayImpl __Instance;

        public QBVirtualFileOverlay()
        {
        }

        public QBVirtualFileOverlay(QuantumBinding.Clang.Interop.CXVirtualFileOverlayImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Map an absolute virtual file path to an absolute real one. The virtual path must be canonicalized (not contain "."/"..").
        ///</summary>
        public CXErrorCode VirtualFileOverlay_addFileMapping(string virtualPath, string realPath)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_addFileMapping(this, virtualPath, realPath);
        }

        ///<summary>
        /// Dispose a CXVirtualFileOverlay object.
        ///</summary>
        public void VirtualFileOverlay_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_dispose(this);
        }

        ///<summary>
        /// Set the case sensitivity for the CXVirtualFileOverlay object. The CXVirtualFileOverlay object is case-sensitive by default, this option can be used to override the default.
        ///</summary>
        public CXErrorCode VirtualFileOverlay_setCaseSensitivity(int caseSensitive)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_setCaseSensitivity(this, caseSensitive);
        }

        ///<summary>
        /// Write out the CXVirtualFileOverlay object to a char buffer.
        ///</summary>
        public CXErrorCode VirtualFileOverlay_writeToBuffer(uint options, out System.IntPtr out_buffer_ptr, out uint out_buffer_size)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_writeToBuffer(this, options, out out_buffer_ptr, out out_buffer_size);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXVirtualFileOverlayImpl(QBVirtualFileOverlay q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXVirtualFileOverlayImpl();
        }

        public static implicit operator QBVirtualFileOverlay(QuantumBinding.Clang.Interop.CXVirtualFileOverlayImpl q)
        {
            return new QBVirtualFileOverlay(q);
        }

    }

    ///<summary>
    /// Object encapsulating information about a module.map file.
    ///</summary>
    public partial class QBModuleMapDescriptor
    {
        internal CXModuleMapDescriptorImpl __Instance;

        public QBModuleMapDescriptor()
        {
        }

        public QBModuleMapDescriptor(QuantumBinding.Clang.Interop.CXModuleMapDescriptorImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Dispose a CXModuleMapDescriptor object.
        ///</summary>
        public void ModuleMapDescriptor_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_dispose(this);
        }

        ///<summary>
        /// Sets the framework module name that the module.map describes.
        ///</summary>
        public CXErrorCode ModuleMapDescriptor_setFrameworkModuleName(string name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_setFrameworkModuleName(this, name);
        }

        ///<summary>
        /// Sets the umbrealla header name that the module.map describes.
        ///</summary>
        public CXErrorCode ModuleMapDescriptor_setUmbrellaHeader(string name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_setUmbrellaHeader(this, name);
        }

        ///<summary>
        /// Write out the CXModuleMapDescriptor object to a char buffer.
        ///</summary>
        public CXErrorCode ModuleMapDescriptor_writeToBuffer(uint options, out System.IntPtr out_buffer_ptr, out uint out_buffer_size)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_writeToBuffer(this, options, out out_buffer_ptr, out out_buffer_size);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXModuleMapDescriptorImpl(QBModuleMapDescriptor q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXModuleMapDescriptorImpl();
        }

        public static implicit operator QBModuleMapDescriptor(QuantumBinding.Clang.Interop.CXModuleMapDescriptorImpl q)
        {
            return new QBModuleMapDescriptor(q);
        }

    }

    ///<summary>
    /// An "index" that consists of a set of translation units that would typically be linked together into an executable or library.
    ///</summary>
    public partial class QBIndex
    {
        internal CXIndexImpl __Instance;

        public QBIndex()
        {
        }

        public QBIndex(QuantumBinding.Clang.Interop.CXIndexImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Same as clang_createTranslationUnit2, but returns the CXTranslationUnit instead of an error code. In case of an error this routine returns a NULL CXTranslationUnit, without further detailed error codes.
        ///</summary>
        public QBTranslationUnit createTranslationUnit(string ast_filename)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_createTranslationUnit(this, ast_filename);
        }

        ///<summary>
        /// Create a translation unit from an AST file ( -emit-ast).
        ///</summary>
        public CXErrorCode createTranslationUnit2(string ast_filename, out QuantumBinding.Clang.QBTranslationUnit out_TU)
        {
            CXTranslationUnitImpl arg1;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_createTranslationUnit2(this, ast_filename, out arg1);
            out_TU = new QBTranslationUnit(arg1);
            return result;
        }

        ///<summary>
        /// Return the CXTranslationUnit for a given source file and the provided command line arguments one would pass to the compiler.
        ///</summary>
        public QBTranslationUnit createTranslationUnitFromSourceFile(string source_filename, int num_clang_command_line_args, in string[] clang_command_line_args, uint num_unsaved_files, QBUnsavedFile unsaved_files)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_createTranslationUnitFromSourceFile(this, source_filename, num_clang_command_line_args, clang_command_line_args, num_unsaved_files, arg1);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Gets the general options associated with a CXIndex.
        ///</summary>
        public uint CXIndex_getGlobalOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_CXIndex_getGlobalOptions(this);
        }

        ///<summary>
        /// Sets general options associated with a CXIndex.
        ///</summary>
        public void CXIndex_setGlobalOptions(uint options)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_CXIndex_setGlobalOptions(this, options);
        }

        ///<summary>
        /// Sets the invocation emission path option in a CXIndex.
        ///</summary>
        public void CXIndex_setInvocationEmissionPathOption(string Path)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_CXIndex_setInvocationEmissionPathOption(this, Path);
        }

        ///<summary>
        /// Destroy the given index.
        ///</summary>
        public void disposeIndex()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeIndex(this);
        }

        ///<summary>
        /// An indexing action/session, to be applied to one or multiple translation units.
        ///</summary>
        public QBIndexAction IndexAction_create()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_IndexAction_create(this);
        }

        ///<summary>
        /// Same as clang_parseTranslationUnit2, but returns the CXTranslationUnit instead of an error code. In case of an error this routine returns a NULL CXTranslationUnit, without further detailed error codes.
        ///</summary>
        public QBTranslationUnit parseTranslationUnit(string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile unsaved_files, uint num_unsaved_files, uint options)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_parseTranslationUnit(this, source_filename, command_line_args, num_command_line_args, arg1, num_unsaved_files, options);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Parse the given source file and the translation unit corresponding to that file.
        ///</summary>
        public CXErrorCode parseTranslationUnit2(string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile[] unsaved_files, uint num_unsaved_files, uint options, out QuantumBinding.Clang.QBTranslationUnit out_TU)
        {
            QuantumBinding.Clang.Interop.CXUnsavedFile[] arg1 = null;
            arg1 = ReferenceEquals(unsaved_files, null) ? null : new QuantumBinding.Clang.Interop.CXUnsavedFile[unsaved_files.Length];
            if (!ReferenceEquals(unsaved_files, null))
            {
                for (var i = 0U; i < unsaved_files.Length; ++i)
                {
                    arg1[i] = unsaved_files[i].ToInternal();
                }
            }
            CXTranslationUnitImpl arg2;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_parseTranslationUnit2(this, source_filename, command_line_args, num_command_line_args, arg1, num_unsaved_files, options, out arg2);
            if (!ReferenceEquals(unsaved_files, null))
            {
                for (var i = 0U; i < unsaved_files.Length; ++i)
                {
                    unsaved_files[i]?.Dispose();
                }
            }
            out_TU = new QBTranslationUnit(arg2);
            return result;
        }

        ///<summary>
        /// Same as clang_parseTranslationUnit2 but requires a full command line for command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.
        ///</summary>
        public CXErrorCode parseTranslationUnit2FullArgv(string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile unsaved_files, uint num_unsaved_files, uint options, out QuantumBinding.Clang.QBTranslationUnit out_TU)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            CXTranslationUnitImpl arg2;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_parseTranslationUnit2FullArgv(this, source_filename, command_line_args, num_command_line_args, arg1, num_unsaved_files, options, out arg2);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            out_TU = new QBTranslationUnit(arg2);
            return result;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIndexImpl(QBIndex q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIndexImpl();
        }

        public static implicit operator QBIndex(QuantumBinding.Clang.Interop.CXIndexImpl q)
        {
            return new QBIndex(q);
        }

    }

    ///<summary>
    /// An opaque type representing target information for a given translation unit.
    ///</summary>
    public partial class QBTargetInfo
    {
        internal CXTargetInfoImpl __Instance;

        public QBTargetInfo()
        {
        }

        public QBTargetInfo(QuantumBinding.Clang.Interop.CXTargetInfoImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Destroy the CXTargetInfo object.
        ///</summary>
        public void TargetInfo_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_TargetInfo_dispose(this);
        }

        ///<summary>
        /// Get the pointer width of the target in bits.
        ///</summary>
        public int TargetInfo_getPointerWidth()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TargetInfo_getPointerWidth(this);
        }

        ///<summary>
        /// Get the normalized target triple as a string.
        ///</summary>
        public QBString TargetInfo_getTriple()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_TargetInfo_getTriple(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXTargetInfoImpl(QBTargetInfo q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXTargetInfoImpl();
        }

        public static implicit operator QBTargetInfo(QuantumBinding.Clang.Interop.CXTargetInfoImpl q)
        {
            return new QBTargetInfo(q);
        }

    }

    ///<summary>
    /// A single translation unit, which resides in an index.
    ///</summary>
    public partial class QBTranslationUnit
    {
        internal CXTranslationUnitImpl __Instance;

        public QBTranslationUnit()
        {
        }

        public QBTranslationUnit(QuantumBinding.Clang.Interop.CXTranslationUnitImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Annotate the given set of tokens by providing cursors for each token that can be mapped to a specific entity within the abstract syntax tree.
        ///</summary>
        public void annotateTokens(QBToken[] Tokens, uint NumTokens, out QBCursor[] Cursors)
        {
            QuantumBinding.Clang.Interop.CXToken[] arg1 = null;
            arg1 = ReferenceEquals(Tokens, null) ? null : new QuantumBinding.Clang.Interop.CXToken[Tokens.Length];
            if (!ReferenceEquals(Tokens, null))
            {
                for (var i = 0U; i < Tokens.Length; ++i)
                {
                    arg1[i] = Tokens[i].ToInternal();
                }
            }
            var arg2 = System.IntPtr.Zero;
            QuantumBinding.Clang.Interop.ClangInterop.clang_annotateTokens(this, arg1, NumTokens, ref arg2);
            if (!ReferenceEquals(Tokens, null))
            {
                for (var i = 0U; i < Tokens.Length; ++i)
                {
                    Tokens[i]?.Dispose();
                }
            }
            var _Cursors = new QuantumBinding.Clang.Interop.CXCursor[NumTokens];
            MarshalUtils.IntPtrToManagedArray<QuantumBinding.Clang.Interop.CXCursor>(arg2, _Cursors);
            Cursors = new QBCursor[NumTokens];
            for (var i = 0U; i< NumTokens; ++i)
            {
                Cursors[i] = new QBCursor(_Cursors[i]);
            }
        }

        ///<summary>
        /// Perform code completion at a given location in a translation unit.
        ///</summary>
        public QBCodeCompleteResults codeCompleteAt(string complete_filename, uint complete_line, uint complete_column, QBUnsavedFile unsaved_files, uint num_unsaved_files, uint options)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteAt(this, complete_filename, complete_line, complete_column, arg1, num_unsaved_files, options);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Returns the set of flags that is suitable for reparsing a translation unit.
        ///</summary>
        public uint defaultReparseOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultReparseOptions(this);
        }

        ///<summary>
        /// Returns the set of flags that is suitable for saving a translation unit.
        ///</summary>
        public uint defaultSaveOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultSaveOptions(this);
        }

        ///<summary>
        /// Free the given set of tokens.
        ///</summary>
        public void disposeTokens(System.IntPtr Tokens, uint NumTokens)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeTokens(this, Tokens, NumTokens);
        }

        ///<summary>
        /// Destroy the specified CXTranslationUnit object.
        ///</summary>
        public void disposeTranslationUnit()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeTranslationUnit(this);
        }

        ///<summary>
        /// Find #import/#include directives in a specific file.
        ///</summary>
        public CXResult findIncludesInFile(QuantumBinding.Clang.QBFile file, QBCursorAndRangeVisitor visitor)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            var arg2 = ReferenceEquals(visitor, null) ? new QuantumBinding.Clang.Interop.CXCursorAndRangeVisitor() : visitor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_findIncludesInFile(this, arg1, arg2);
            visitor?.Dispose();
            return result;
        }

        ///<summary>
        /// Retrieve all ranges from all files that were skipped by the preprocessor.
        ///</summary>
        public QBSourceRangeList getAllSkippedRanges()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getAllSkippedRanges(this);
        }

        ///<summary>
        /// Map a source location to the cursor that describes the entity at that location in the source code.
        ///</summary>
        public QBCursor getCursor(QBSourceLocation param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : param1.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCursor(this, arg1);
            return result;
        }

        ///<summary>
        /// Return the memory usage of a translation unit. This object should be released with clang_disposeCXTUResourceUsage().
        ///</summary>
        public QBTUResourceUsage getCXTUResourceUsage()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCXTUResourceUsage(this);
        }

        ///<summary>
        /// Retrieve a diagnostic associated with the given translation unit.
        ///</summary>
        public QBDiagnostic getDiagnostic(uint Index)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnostic(this, Index);
        }

        ///<summary>
        /// Retrieve the complete set of diagnostics associated with a translation unit.
        ///</summary>
        public QBDiagnosticSet getDiagnosticSetFromTU()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticSetFromTU(this);
        }

        ///<summary>
        /// Retrieve a file handle within the given translation unit.
        ///</summary>
        public QBFile getFile(string file_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFile(this, file_name);
        }

        ///<summary>
        /// Retrieve the buffer associated with the given file.
        ///</summary>
        public string getFileContents(QuantumBinding.Clang.QBFile file, out ulong size)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileContents(this, arg1, out size);
        }

        ///<summary>
        /// Visit the set of preprocessor inclusions in a translation unit. The visitor function is called with the provided data for every included file. This does not include headers included by the PCH file (unless one is inspecting the inclusions in the PCH file itself).
        ///</summary>
        public void getInclusions(System.IntPtr visitor, QuantumBinding.Clang.QBClientData client_data)
        {
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            QuantumBinding.Clang.Interop.ClangInterop.clang_getInclusions(this, visitor, arg1);
        }

        ///<summary>
        /// Retrieves the source location associated with a given file/line/column in a particular translation unit.
        ///</summary>
        public QBSourceLocation getLocation(QuantumBinding.Clang.QBFile file, uint line, uint column)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getLocation(this, arg1, line, column);
        }

        ///<summary>
        /// Retrieves the source location associated with a given character offset in a particular translation unit.
        ///</summary>
        public QBSourceLocation getLocationForOffset(QuantumBinding.Clang.QBFile file, uint offset)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getLocationForOffset(this, arg1, offset);
        }

        ///<summary>
        /// Given a CXFile header file, return the module that contains it, if one exists.
        ///</summary>
        public QBModule getModuleForFile(QuantumBinding.Clang.QBFile param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new CXFileImpl() : (CXFileImpl)param1;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getModuleForFile(this, arg1);
        }

        ///<summary>
        /// Determine the number of diagnostics produced for the given translation unit.
        ///</summary>
        public uint getNumDiagnostics()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumDiagnostics(this);
        }

        ///<summary>
        /// Retrieve all ranges that were skipped by the preprocessor.
        ///</summary>
        public QBSourceRangeList getSkippedRanges(QuantumBinding.Clang.QBFile file)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getSkippedRanges(this, arg1);
        }

        ///<summary>
        /// Get the raw lexical token starting with the given location.
        ///</summary>
        public QBToken getToken(QBSourceLocation Location)
        {
            var arg1 = ReferenceEquals(Location, null) ? new QuantumBinding.Clang.Interop.CXSourceLocation() : Location.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getToken(this, arg1);
            return result;
        }

        ///<summary>
        /// Retrieve a source range that covers the given token.
        ///</summary>
        public QBSourceRange getTokenExtent(QBToken param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new QuantumBinding.Clang.Interop.CXToken() : param1.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenExtent(this, arg1);
            param1?.Dispose();
            return result;
        }

        ///<summary>
        /// Retrieve the source location of the given token.
        ///</summary>
        public QBSourceLocation getTokenLocation(QBToken param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new QuantumBinding.Clang.Interop.CXToken() : param1.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenLocation(this, arg1);
            param1?.Dispose();
            return result;
        }

        ///<summary>
        /// Determine the spelling of the given token.
        ///</summary>
        public QBString getTokenSpelling(QBToken param1)
        {
            var arg1 = ReferenceEquals(param1, null) ? new QuantumBinding.Clang.Interop.CXToken() : param1.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getTokenSpelling(this, arg1);
            param1?.Dispose();
            return result;
        }

        ///<summary>
        /// Retrieve the cursor that represents the given translation unit.
        ///</summary>
        public QBCursor getTranslationUnitCursor()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTranslationUnitCursor(this);
        }

        ///<summary>
        /// Get the original translation unit source file name.
        ///</summary>
        public QBString getTranslationUnitSpelling()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTranslationUnitSpelling(this);
        }

        ///<summary>
        /// Get target information for this translation unit.
        ///</summary>
        public QBTargetInfo getTranslationUnitTargetInfo()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTranslationUnitTargetInfo(this);
        }

        ///<summary>
        /// Determine whether the given header is guarded against multiple inclusions, either with the conventional #ifndef/#define/#endif macro guards or with #pragma once.
        ///</summary>
        public uint isFileMultipleIncludeGuarded(QuantumBinding.Clang.QBFile file)
        {
            var arg1 = ReferenceEquals(file, null) ? new CXFileImpl() : (CXFileImpl)file;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isFileMultipleIncludeGuarded(this, arg1);
        }

        ///<summary>
        /// Returns the number of top level headers associated with this module.
        ///</summary>
        public uint Module_getNumTopLevelHeaders(QuantumBinding.Clang.QBModule Module)
        {
            var arg1 = ReferenceEquals(Module, null) ? new CXModuleImpl() : (CXModuleImpl)Module;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getNumTopLevelHeaders(this, arg1);
        }

        ///<summary>
        /// Returns the specified top level header associated with the module.
        ///</summary>
        public QBFile Module_getTopLevelHeader(QuantumBinding.Clang.QBModule Module, uint Index)
        {
            var arg1 = ReferenceEquals(Module, null) ? new CXModuleImpl() : (CXModuleImpl)Module;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getTopLevelHeader(this, arg1, Index);
        }

        ///<summary>
        /// Reparse the source files that produced this translation unit.
        ///</summary>
        public int reparseTranslationUnit(uint num_unsaved_files, QBUnsavedFile unsaved_files, uint options)
        {
            var arg1 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_reparseTranslationUnit(this, num_unsaved_files, arg1, options);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Saves a translation unit into a serialized representation of that translation unit on disk.
        ///</summary>
        public int saveTranslationUnit(string FileName, uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_saveTranslationUnit(this, FileName, options);
        }

        ///<summary>
        /// Suspend a translation unit in order to free memory associated with it.
        ///</summary>
        public uint suspendTranslationUnit()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_suspendTranslationUnit(this);
        }

        ///<summary>
        /// Tokenize the source code described by the given range into raw lexical tokens.
        ///</summary>
        public void tokenize(QBSourceRange Range, out QBToken[] Tokens, out uint NumTokens)
        {
            var arg1 = ReferenceEquals(Range, null) ? new QuantumBinding.Clang.Interop.CXSourceRange() : Range.ToInternal();
            var arg2 = System.IntPtr.Zero;
            QuantumBinding.Clang.Interop.ClangInterop.clang_tokenize(this, arg1, ref arg2, out NumTokens);
            var _Tokens = new QuantumBinding.Clang.Interop.CXToken[NumTokens];
            MarshalUtils.IntPtrToManagedArray<QuantumBinding.Clang.Interop.CXToken>(arg2, _Tokens);
            Tokens = new QBToken[NumTokens];
            for (var i = 0U; i< NumTokens; ++i)
            {
                Tokens[i] = new QBToken(_Tokens[i]);
            }
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXTranslationUnitImpl(QBTranslationUnit q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXTranslationUnitImpl();
        }

        public static implicit operator QBTranslationUnit(QuantumBinding.Clang.Interop.CXTranslationUnitImpl q)
        {
            return new QBTranslationUnit(q);
        }

    }

    ///<summary>
    /// Opaque pointer representing client data that will be passed through to various callbacks and visitors.
    ///</summary>
    public partial class QBClientData
    {
        internal CXClientDataImpl __Instance;

        public QBClientData()
        {
        }

        public QBClientData(QuantumBinding.Clang.Interop.CXClientDataImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXClientDataImpl(QBClientData q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXClientDataImpl();
        }

        public static implicit operator QBClientData(QuantumBinding.Clang.Interop.CXClientDataImpl q)
        {
            return new QBClientData(q);
        }

    }

    ///<summary>
    /// A particular source file that is part of a translation unit.
    ///</summary>
    public partial class QBFile
    {
        internal CXFileImpl __Instance;

        public QBFile()
        {
        }

        public QBFile(QuantumBinding.Clang.Interop.CXFileImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Returns non-zero if the file1 and file2 point to the same file, or they are both NULL.
        ///</summary>
        public int File_isEqual(QuantumBinding.Clang.QBFile file2)
        {
            var arg1 = ReferenceEquals(file2, null) ? new CXFileImpl() : (CXFileImpl)file2;
            return QuantumBinding.Clang.Interop.ClangInterop.clang_File_isEqual(this, arg1);
        }

        ///<summary>
        /// Returns the real path name of file.
        ///</summary>
        public QBString File_tryGetRealPathName()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_File_tryGetRealPathName(this);
        }

        ///<summary>
        /// Retrieve the complete file and path name of the given file.
        ///</summary>
        public QBString getFileName()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileName(this);
        }

        ///<summary>
        /// Retrieve the last modification time of the given file.
        ///</summary>
        public long getFileTime()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getFileTime(this);
        }

        ///<summary>
        /// Retrieve the unique ID for the given file.
        ///</summary>
        public int getFileUniqueID(out QBFileUniqueID outID)
        {
            CXFileUniqueID arg1;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getFileUniqueID(this, out arg1);
            outID = new QBFileUniqueID(arg1);
            return result;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXFileImpl(QBFile q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXFileImpl();
        }

        public static implicit operator QBFile(QuantumBinding.Clang.Interop.CXFileImpl q)
        {
            return new QBFile(q);
        }

    }

    ///<summary>
    /// A single diagnostic, containing the diagnostic's severity, location, text, source ranges, and fix-it hints.
    ///</summary>
    public partial class QBDiagnostic
    {
        internal CXDiagnosticImpl __Instance;

        public QBDiagnostic()
        {
        }

        public QBDiagnostic(QuantumBinding.Clang.Interop.CXDiagnosticImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Destroy a diagnostic.
        ///</summary>
        public void disposeDiagnostic()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeDiagnostic(this);
        }

        ///<summary>
        /// Format the given diagnostic in a manner that is suitable for display.
        ///</summary>
        public QBString formatDiagnostic(uint Options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_formatDiagnostic(this, Options);
        }

        ///<summary>
        /// Retrieve the child diagnostics of a CXDiagnostic.
        ///</summary>
        public QBDiagnosticSet getChildDiagnostics()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getChildDiagnostics(this);
        }

        ///<summary>
        /// Retrieve the category number for this diagnostic.
        ///</summary>
        public uint getDiagnosticCategory()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticCategory(this);
        }

        ///<summary>
        /// Retrieve the diagnostic category text for a given diagnostic.
        ///</summary>
        public QBString getDiagnosticCategoryText()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticCategoryText(this);
        }

        ///<summary>
        /// Retrieve the replacement information for a given fix-it.
        ///</summary>
        public QBString getDiagnosticFixIt(uint FixIt, QBSourceRange ReplacementRange)
        {
            var arg1 = ReferenceEquals(ReplacementRange, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(ReplacementRange.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticFixIt(this, FixIt, arg1);
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Retrieve the source location of the given diagnostic.
        ///</summary>
        public QBSourceLocation getDiagnosticLocation()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticLocation(this);
        }

        ///<summary>
        /// Determine the number of fix-it hints associated with the given diagnostic.
        ///</summary>
        public uint getDiagnosticNumFixIts()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticNumFixIts(this);
        }

        ///<summary>
        /// Determine the number of source ranges associated with the given diagnostic.
        ///</summary>
        public uint getDiagnosticNumRanges()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticNumRanges(this);
        }

        ///<summary>
        /// Retrieve the name of the command-line option that enabled this diagnostic.
        ///</summary>
        public QBString getDiagnosticOption(QBString Disable)
        {
            var arg1 = ReferenceEquals(Disable, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(Disable.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticOption(this, arg1);
            Disable?.Dispose();
            Marshal.FreeHGlobal(arg1);
            return result;
        }

        ///<summary>
        /// Retrieve a source range associated with the diagnostic.
        ///</summary>
        public QBSourceRange getDiagnosticRange(uint Range)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticRange(this, Range);
        }

        ///<summary>
        /// Determine the severity of the given diagnostic.
        ///</summary>
        public CXDiagnosticSeverity getDiagnosticSeverity()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticSeverity(this);
        }

        ///<summary>
        /// Retrieve the text of the given diagnostic.
        ///</summary>
        public QBString getDiagnosticSpelling()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticSpelling(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXDiagnosticImpl(QBDiagnostic q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXDiagnosticImpl();
        }

        public static implicit operator QBDiagnostic(QuantumBinding.Clang.Interop.CXDiagnosticImpl q)
        {
            return new QBDiagnostic(q);
        }

    }

    ///<summary>
    /// A group of CXDiagnostics.
    ///</summary>
    public partial class QBDiagnosticSet
    {
        internal CXDiagnosticSetImpl __Instance;

        public QBDiagnosticSet()
        {
        }

        public QBDiagnosticSet(QuantumBinding.Clang.Interop.CXDiagnosticSetImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Release a CXDiagnosticSet and all of its contained diagnostics.
        ///</summary>
        public void disposeDiagnosticSet()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeDiagnosticSet(this);
        }

        ///<summary>
        /// Retrieve a diagnostic associated with the given CXDiagnosticSet.
        ///</summary>
        public QBDiagnostic getDiagnosticInSet(uint Index)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticInSet(this, Index);
        }

        ///<summary>
        /// Determine the number of diagnostics in a CXDiagnosticSet.
        ///</summary>
        public uint getNumDiagnosticsInSet()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumDiagnosticsInSet(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXDiagnosticSetImpl(QBDiagnosticSet q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXDiagnosticSetImpl();
        }

        public static implicit operator QBDiagnosticSet(QuantumBinding.Clang.Interop.CXDiagnosticSetImpl q)
        {
            return new QBDiagnosticSet(q);
        }

    }

    ///<summary>
    /// A fast container representing a set of CXCursors.
    ///</summary>
    public partial class QBCursorSet
    {
        internal CXCursorSetImpl __Instance;

        public QBCursorSet()
        {
        }

        public QBCursorSet(QuantumBinding.Clang.Interop.CXCursorSetImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Creates an empty CXCursorSet.
        ///</summary>
        public static QBCursorSet createCXCursorSet()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_createCXCursorSet();
        }

        ///<summary>
        /// Queries a CXCursorSet to see if it contains a specific CXCursor.
        ///</summary>
        public uint CXCursorSet_contains(QBCursor cursor)
        {
            var arg1 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXCursorSet_contains(this, arg1);
            return result;
        }

        ///<summary>
        /// Inserts a CXCursor into a CXCursorSet.
        ///</summary>
        public uint CXCursorSet_insert(QBCursor cursor)
        {
            var arg1 = ReferenceEquals(cursor, null) ? new QuantumBinding.Clang.Interop.CXCursor() : cursor.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_CXCursorSet_insert(this, arg1);
            return result;
        }

        ///<summary>
        /// Disposes a CXCursorSet and releases its associated memory.
        ///</summary>
        public void disposeCXCursorSet()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_disposeCXCursorSet(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXCursorSetImpl(QBCursorSet q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXCursorSetImpl();
        }

        public static implicit operator QBCursorSet(QuantumBinding.Clang.Interop.CXCursorSetImpl q)
        {
            return new QBCursorSet(q);
        }

    }

    ///<summary>
    /// Opaque pointer representing a policy that controls pretty printing for clang_getCursorPrettyPrinted.
    ///</summary>
    public partial class QBPrintingPolicy
    {
        internal CXPrintingPolicyImpl __Instance;

        public QBPrintingPolicy()
        {
        }

        public QBPrintingPolicy(QuantumBinding.Clang.Interop.CXPrintingPolicyImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Release a printing policy.
        ///</summary>
        public void PrintingPolicy_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_PrintingPolicy_dispose(this);
        }

        ///<summary>
        /// Get a property value for the given printing policy.
        ///</summary>
        public uint PrintingPolicy_getProperty(CXPrintingPolicyProperty Property)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_PrintingPolicy_getProperty(this, Property);
        }

        ///<summary>
        /// Set a property value for the given printing policy.
        ///</summary>
        public void PrintingPolicy_setProperty(CXPrintingPolicyProperty Property, uint Value)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_PrintingPolicy_setProperty(this, Property, Value);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXPrintingPolicyImpl(QBPrintingPolicy q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXPrintingPolicyImpl();
        }

        public static implicit operator QBPrintingPolicy(QuantumBinding.Clang.Interop.CXPrintingPolicyImpl q)
        {
            return new QBPrintingPolicy(q);
        }

    }

    ///<summary>
    /// The functions in this group provide access to information about modules.
    ///</summary>
    public partial class QBModule
    {
        internal CXModuleImpl __Instance;

        public QBModule()
        {
        }

        public QBModule(QuantumBinding.Clang.Interop.CXModuleImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Returns the module file where the provided module object came from.
        ///</summary>
        public QBFile Module_getASTFile()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getASTFile(this);
        }

        ///<summary>
        /// Returns the full name of the module, e.g. "std.vector".
        ///</summary>
        public QBString Module_getFullName()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getFullName(this);
        }

        ///<summary>
        /// Returns the name of the module, e.g. for the 'std.vector' sub-module it will return "vector".
        ///</summary>
        public QBString Module_getName()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getName(this);
        }

        ///<summary>
        /// Returns the parent of a sub-module or NULL if the given module is top-level, e.g. for 'std.vector' it will return the 'std' module.
        ///</summary>
        public QBModule Module_getParent()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_getParent(this);
        }

        ///<summary>
        /// Returns non-zero if the module is a system one.
        ///</summary>
        public int Module_isSystem()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_Module_isSystem(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXModuleImpl(QBModule q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXModuleImpl();
        }

        public static implicit operator QBModule(QuantumBinding.Clang.Interop.CXModuleImpl q)
        {
            return new QBModule(q);
        }

    }

    ///<summary>
    /// A semantic string that describes a code-completion result.
    ///</summary>
    public partial class QBCompletionString
    {
        internal CXCompletionStringImpl __Instance;

        public QBCompletionString()
        {
        }

        public QBCompletionString(QuantumBinding.Clang.Interop.CXCompletionStringImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Retrieve the annotation associated with the given completion string.
        ///</summary>
        public QBString getCompletionAnnotation(uint annotation_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionAnnotation(this, annotation_number);
        }

        ///<summary>
        /// Determine the availability of the entity that this code-completion string refers to.
        ///</summary>
        public CXAvailabilityKind getCompletionAvailability()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionAvailability(this);
        }

        ///<summary>
        /// Retrieve the brief documentation comment attached to the declaration that corresponds to the given completion string.
        ///</summary>
        public QBString getCompletionBriefComment()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionBriefComment(this);
        }

        ///<summary>
        /// Retrieve the completion string associated with a particular chunk within a completion string.
        ///</summary>
        public QBCompletionString getCompletionChunkCompletionString(uint chunk_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionChunkCompletionString(this, chunk_number);
        }

        ///<summary>
        /// Determine the kind of a particular chunk within a completion string.
        ///</summary>
        public CXCompletionChunkKind getCompletionChunkKind(uint chunk_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionChunkKind(this, chunk_number);
        }

        ///<summary>
        /// Retrieve the text associated with a particular chunk within a completion string.
        ///</summary>
        public QBString getCompletionChunkText(uint chunk_number)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionChunkText(this, chunk_number);
        }

        ///<summary>
        /// Retrieve the number of annotations associated with the given completion string.
        ///</summary>
        public uint getCompletionNumAnnotations()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionNumAnnotations(this);
        }

        ///<summary>
        /// Retrieve the parent context of the given completion string.
        ///</summary>
        public QBString getCompletionParent(ref CXCursorKind kind)
        {
            var arg1 = (uint)kind;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionParent(this, ref arg1);
            kind = (CXCursorKind)arg1;
            return result;
        }

        ///<summary>
        /// Determine the priority of this code completion.
        ///</summary>
        public uint getCompletionPriority()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCompletionPriority(this);
        }

        ///<summary>
        /// Retrieve the number of chunks in the given code-completion string.
        ///</summary>
        public uint getNumCompletionChunks()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNumCompletionChunks(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXCompletionStringImpl(QBCompletionString q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXCompletionStringImpl();
        }

        public static implicit operator QBCompletionString(QuantumBinding.Clang.Interop.CXCompletionStringImpl q)
        {
            return new QBCompletionString(q);
        }

    }

    ///<summary>
    /// Evaluation result of a cursor
    ///</summary>
    public partial class QBEvalResult
    {
        internal CXEvalResultImpl __Instance;

        public QBEvalResult()
        {
        }

        public QBEvalResult(QuantumBinding.Clang.Interop.CXEvalResultImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Disposes the created Eval memory.
        ///</summary>
        public void EvalResult_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_dispose(this);
        }

        ///<summary>
        /// Returns the evaluation result as double if the kind is double.
        ///</summary>
        public double EvalResult_getAsDouble()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsDouble(this);
        }

        ///<summary>
        /// Returns the evaluation result as integer if the kind is Int.
        ///</summary>
        public int EvalResult_getAsInt()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsInt(this);
        }

        ///<summary>
        /// Returns the evaluation result as a long long integer if the kind is Int. This prevents overflows that may happen if the result is returned with clang_EvalResult_getAsInt.
        ///</summary>
        public long EvalResult_getAsLongLong()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsLongLong(this);
        }

        ///<summary>
        /// Returns the evaluation result as a constant string if the kind is other than Int or float. User must not free this pointer, instead call clang_EvalResult_dispose on the CXEvalResult returned by clang_Cursor_Evaluate.
        ///</summary>
        public string EvalResult_getAsStr()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsStr(this);
        }

        ///<summary>
        /// Returns the evaluation result as an unsigned integer if the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.
        ///</summary>
        public ulong EvalResult_getAsUnsigned()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getAsUnsigned(this);
        }

        ///<summary>
        /// Returns the kind of the evaluated result.
        ///</summary>
        public CXEvalResultKind EvalResult_getKind()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_getKind(this);
        }

        ///<summary>
        /// Returns a non-zero value if the kind is Int and the evaluation result resulted in an unsigned integer.
        ///</summary>
        public uint EvalResult_isUnsignedInt()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_EvalResult_isUnsignedInt(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXEvalResultImpl(QBEvalResult q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXEvalResultImpl();
        }

        public static implicit operator QBEvalResult(QuantumBinding.Clang.Interop.CXEvalResultImpl q)
        {
            return new QBEvalResult(q);
        }

    }

    ///<summary>
    /// A remapping of original source files and their translated files.
    ///</summary>
    public partial class QBRemapping
    {
        internal CXRemappingImpl __Instance;

        public QBRemapping()
        {
        }

        public QBRemapping(QuantumBinding.Clang.Interop.CXRemappingImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Dispose the remapping.
        ///</summary>
        public void remap_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_remap_dispose(this);
        }

        ///<summary>
        /// Get the original and the associated filename from the remapping.
        ///</summary>
        public void remap_getFilenames(uint index, out QBString original, out QBString transformed)
        {
            CXString arg1;
            CXString arg2;
            QuantumBinding.Clang.Interop.ClangInterop.clang_remap_getFilenames(this, index, out arg1, out arg2);
            original = new QBString(arg1);
            transformed = new QBString(arg2);
        }

        ///<summary>
        /// Determine the number of remappings.
        ///</summary>
        public uint remap_getNumFiles()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_remap_getNumFiles(this);
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXRemappingImpl(QBRemapping q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXRemappingImpl();
        }

        public static implicit operator QBRemapping(QuantumBinding.Clang.Interop.CXRemappingImpl q)
        {
            return new QBRemapping(q);
        }

    }

    ///<summary>
    /// The client's data object that is associated with a CXFile.
    ///</summary>
    public partial class QBIdxClientFile
    {
        internal CXIdxClientFileImpl __Instance;

        public QBIdxClientFile()
        {
        }

        public QBIdxClientFile(QuantumBinding.Clang.Interop.CXIdxClientFileImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIdxClientFileImpl(QBIdxClientFile q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIdxClientFileImpl();
        }

        public static implicit operator QBIdxClientFile(QuantumBinding.Clang.Interop.CXIdxClientFileImpl q)
        {
            return new QBIdxClientFile(q);
        }

    }

    ///<summary>
    /// The client's data object that is associated with a semantic entity.
    ///</summary>
    public partial class QBIdxClientEntity
    {
        internal CXIdxClientEntityImpl __Instance;

        public QBIdxClientEntity()
        {
        }

        public QBIdxClientEntity(QuantumBinding.Clang.Interop.CXIdxClientEntityImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIdxClientEntityImpl(QBIdxClientEntity q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIdxClientEntityImpl();
        }

        public static implicit operator QBIdxClientEntity(QuantumBinding.Clang.Interop.CXIdxClientEntityImpl q)
        {
            return new QBIdxClientEntity(q);
        }

    }

    ///<summary>
    /// The client's data object that is associated with a semantic container of entities.
    ///</summary>
    public partial class QBIdxClientContainer
    {
        internal CXIdxClientContainerImpl __Instance;

        public QBIdxClientContainer()
        {
        }

        public QBIdxClientContainer(QuantumBinding.Clang.Interop.CXIdxClientContainerImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIdxClientContainerImpl(QBIdxClientContainer q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIdxClientContainerImpl();
        }

        public static implicit operator QBIdxClientContainer(QuantumBinding.Clang.Interop.CXIdxClientContainerImpl q)
        {
            return new QBIdxClientContainer(q);
        }

    }

    ///<summary>
    /// The client's data object that is associated with an AST file (PCH or module).
    ///</summary>
    public partial class QBIdxClientASTFile
    {
        internal CXIdxClientASTFileImpl __Instance;

        public QBIdxClientASTFile()
        {
        }

        public QBIdxClientASTFile(QuantumBinding.Clang.Interop.CXIdxClientASTFileImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIdxClientASTFileImpl(QBIdxClientASTFile q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIdxClientASTFileImpl();
        }

        public static implicit operator QBIdxClientASTFile(QuantumBinding.Clang.Interop.CXIdxClientASTFileImpl q)
        {
            return new QBIdxClientASTFile(q);
        }

    }

    ///<summary>
    /// An indexing action/session, to be applied to one or multiple translation units.
    ///</summary>
    public partial class QBIndexAction
    {
        internal CXIndexActionImpl __Instance;

        public QBIndexAction()
        {
        }

        public QBIndexAction(QuantumBinding.Clang.Interop.CXIndexActionImpl __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Destroy the given index action.
        ///</summary>
        public void IndexAction_dispose()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_IndexAction_dispose(this);
        }

        ///<summary>
        /// Index the given source file and the translation unit corresponding to that file via callbacks implemented through #IndexerCallbacks.
        ///</summary>
        public int indexSourceFile(QuantumBinding.Clang.QBClientData client_data, IndexerCallbacks index_callbacks, uint index_callbacks_size, uint index_options, string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile unsaved_files, uint num_unsaved_files, out QuantumBinding.Clang.QBTranslationUnit out_TU, uint TU_options)
        {
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            var arg2 = ReferenceEquals(index_callbacks, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(index_callbacks.ToInternal());
            var arg3 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            CXTranslationUnitImpl arg4;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexSourceFile(this, arg1, arg2, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, arg3, num_unsaved_files, out arg4, TU_options);
            index_callbacks?.Dispose();
            Marshal.FreeHGlobal(arg2);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg3);
            out_TU = new QBTranslationUnit(arg4);
            return result;
        }

        ///<summary>
        /// Same as clang_indexSourceFile but requires a full command line for command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.
        ///</summary>
        public int indexSourceFileFullArgv(QuantumBinding.Clang.QBClientData client_data, IndexerCallbacks index_callbacks, uint index_callbacks_size, uint index_options, string source_filename, in string[] command_line_args, int num_command_line_args, QBUnsavedFile unsaved_files, uint num_unsaved_files, out QuantumBinding.Clang.QBTranslationUnit out_TU, uint TU_options)
        {
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            var arg2 = ReferenceEquals(index_callbacks, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(index_callbacks.ToInternal());
            var arg3 = ReferenceEquals(unsaved_files, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(unsaved_files.ToInternal());
            CXTranslationUnitImpl arg4;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexSourceFileFullArgv(this, arg1, arg2, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, arg3, num_unsaved_files, out arg4, TU_options);
            index_callbacks?.Dispose();
            Marshal.FreeHGlobal(arg2);
            unsaved_files?.Dispose();
            Marshal.FreeHGlobal(arg3);
            out_TU = new QBTranslationUnit(arg4);
            return result;
        }

        ///<summary>
        /// Index the given translation unit via callbacks implemented through #IndexerCallbacks.
        ///</summary>
        public int indexTranslationUnit(QuantumBinding.Clang.QBClientData client_data, IndexerCallbacks index_callbacks, uint index_callbacks_size, uint index_options, QuantumBinding.Clang.QBTranslationUnit param5)
        {
            var arg1 = ReferenceEquals(client_data, null) ? new CXClientDataImpl() : (CXClientDataImpl)client_data;
            var arg2 = ReferenceEquals(index_callbacks, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(index_callbacks.ToInternal());
            var arg3 = ReferenceEquals(param5, null) ? new CXTranslationUnitImpl() : (CXTranslationUnitImpl)param5;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_indexTranslationUnit(this, arg1, arg2, index_callbacks_size, index_options, arg3);
            index_callbacks?.Dispose();
            Marshal.FreeHGlobal(arg2);
            return result;
        }

        public static implicit operator QuantumBinding.Clang.Interop.CXIndexActionImpl(QBIndexAction q)
        {
            return q?.__Instance ?? new QuantumBinding.Clang.Interop.CXIndexActionImpl();
        }

        public static implicit operator QBIndexAction(QuantumBinding.Clang.Interop.CXIndexActionImpl q)
        {
            return new QBIndexAction(q);
        }

    }

    public static class clang
    {
        ///<summary>
        /// Return the timestamp for use with Clang's -fbuild-session-timestamp= option.
        ///</summary>
        public static ulong getBuildSessionTimestamp()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getBuildSessionTimestamp();
        }

        ///<summary>
        /// Create a CXVirtualFileOverlay object. Must be disposed with clang_VirtualFileOverlay_dispose().
        ///</summary>
        public static QBVirtualFileOverlay VirtualFileOverlay_create(uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_VirtualFileOverlay_create(options);
        }

        ///<summary>
        /// free memory allocated by libclang, such as the buffer returned by CXVirtualFileOverlay() or clang_ModuleMapDescriptor_writeToBuffer().
        ///</summary>
        public static void free(ref System.IntPtr buffer)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_free(buffer);
        }

        ///<summary>
        /// Create a CXModuleMapDescriptor object. Must be disposed with clang_ModuleMapDescriptor_dispose().
        ///</summary>
        public static QBModuleMapDescriptor ModuleMapDescriptor_create(uint options)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_ModuleMapDescriptor_create(options);
        }

        ///<summary>
        /// Provides a shared context for creating translation units.
        ///</summary>
        public static QBIndex createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_createIndex(excludeDeclarationsFromPCH, displayDiagnostics);
        }

        ///<summary>
        /// Retrieve a NULL (invalid) source location.
        ///</summary>
        public static QBSourceLocation getNullLocation()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNullLocation();
        }

        ///<summary>
        /// Retrieve a NULL (invalid) source range.
        ///</summary>
        public static QBSourceRange getNullRange()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNullRange();
        }

        ///<summary>
        /// Deserialize a set of diagnostics from a Clang diagnostics bitcode file.
        ///</summary>
        public static QBDiagnosticSet loadDiagnostics(string file, out CXLoadDiag_Error error, out QBString errorString)
        {
            CXString arg1;
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_loadDiagnostics(file, out error, out arg1);
            errorString = new QBString(arg1);
            return result;
        }

        ///<summary>
        /// Retrieve the set of display options most similar to the default behavior of the clang compiler.
        ///</summary>
        public static uint defaultDiagnosticDisplayOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultDiagnosticDisplayOptions();
        }

        ///<summary>
        /// Retrieve the name of a particular diagnostic category. This is now deprecated. Use clang_getDiagnosticCategoryText() instead.
        ///</summary>
        public static QBString getDiagnosticCategoryName(uint Category)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getDiagnosticCategoryName(Category);
        }

        ///<summary>
        /// Returns the set of flags that is suitable for parsing a translation unit that is being edited.
        ///</summary>
        public static uint defaultEditingTranslationUnitOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultEditingTranslationUnitOptions();
        }

        ///<summary>
        /// Returns the human-readable null-terminated C string that represents the name of the memory category. This string should never be freed.
        ///</summary>
        public static string getTUResourceUsageName(CXTUResourceUsageKind kind)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTUResourceUsageName(kind);
        }

        ///<summary>
        /// Retrieve the NULL cursor, which represents no entity.
        ///</summary>
        public static QBCursor getNullCursor()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getNullCursor();
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a declaration.
        ///</summary>
        public static uint isDeclaration(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isDeclaration(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a simple reference.
        ///</summary>
        public static uint isReference(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isReference(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents an expression.
        ///</summary>
        public static uint isExpression(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isExpression(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a statement.
        ///</summary>
        public static uint isStatement(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isStatement(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents an attribute.
        ///</summary>
        public static uint isAttribute(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isAttribute(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents an invalid cursor.
        ///</summary>
        public static uint isInvalid(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isInvalid(param0);
        }

        ///<summary>
        /// Determine whether the given cursor kind represents a translation unit.
        ///</summary>
        public static uint isTranslationUnit(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isTranslationUnit(param0);
        }

        ///<summary>
        /// * Determine whether the given cursor represents a preprocessing element, such as a preprocessor directive or macro instantiation.
        ///</summary>
        public static uint isPreprocessing(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isPreprocessing(param0);
        }

        ///<summary>
        /// * Determine whether the given cursor represents a currently unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).
        ///</summary>
        public static uint isUnexposed(CXCursorKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_isUnexposed(param0);
        }

        ///<summary>
        /// Retrieve the spelling of a given CXTypeKind.
        ///</summary>
        public static QBString getTypeKindSpelling(CXTypeKind K)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getTypeKindSpelling(K);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C class.
        ///</summary>
        public static QBString constructUSR_ObjCClass(string class_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCClass(class_name);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C category.
        ///</summary>
        public static QBString constructUSR_ObjCCategory(string class_name, string category_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCCategory(class_name, category_name);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C protocol.
        ///</summary>
        public static QBString constructUSR_ObjCProtocol(string protocol_name)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCProtocol(protocol_name);
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C instance variable and the USR for its containing class.
        ///</summary>
        public static QBString constructUSR_ObjCIvar(string name, QBString classUSR)
        {
            var arg0 = ReferenceEquals(classUSR, null) ? new QuantumBinding.Clang.Interop.CXString() : classUSR.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCIvar(name, arg0);
            classUSR?.Dispose();
            return result;
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C method and the USR for its containing class.
        ///</summary>
        public static QBString constructUSR_ObjCMethod(string name, uint isInstanceMethod, QBString classUSR)
        {
            var arg0 = ReferenceEquals(classUSR, null) ? new QuantumBinding.Clang.Interop.CXString() : classUSR.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCMethod(name, isInstanceMethod, arg0);
            classUSR?.Dispose();
            return result;
        }

        ///<summary>
        /// Construct a USR for a specified Objective-C property and the USR for its containing class.
        ///</summary>
        public static QBString constructUSR_ObjCProperty(string property, QBString classUSR)
        {
            var arg0 = ReferenceEquals(classUSR, null) ? new QuantumBinding.Clang.Interop.CXString() : classUSR.ToInternal();
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_constructUSR_ObjCProperty(property, arg0);
            classUSR?.Dispose();
            return result;
        }

        ///<summary>
        /// for debug/testing
        ///</summary>
        public static QBString getCursorKindSpelling(CXCursorKind Kind)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getCursorKindSpelling(Kind);
        }

        public static void enableStackTraces()
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_enableStackTraces();
        }

        public static void executeOnThread(System.IntPtr fn, ref System.IntPtr user_data, uint stack_size)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_executeOnThread(fn, user_data, stack_size);
        }

        ///<summary>
        /// Returns a default set of code-completion options that can be passed to clang_codeCompleteAt().
        ///</summary>
        public static uint defaultCodeCompleteOptions()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_defaultCodeCompleteOptions();
        }

        ///<summary>
        /// Sort the code-completion results in case-insensitive alphabetical order.
        ///</summary>
        public static void sortCodeCompletionResults(QBCodeCompleteResults[] Results, uint NumResults)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            QuantumBinding.Clang.Interop.ClangInterop.clang_sortCodeCompletionResults(arg0, NumResults);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
        }

        ///<summary>
        /// Determine the number of diagnostics produced prior to the location where code completion was performed.
        ///</summary>
        public static uint codeCompleteGetNumDiagnostics(QBCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetNumDiagnostics(arg0);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Retrieve a diagnostic associated with the given code completion.
        ///</summary>
        public static QBDiagnostic codeCompleteGetDiagnostic(QBCodeCompleteResults[] Results, uint Index)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetDiagnostic(arg0, Index);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Determines what completions are appropriate for the context the given code completion.
        ///</summary>
        public static ulong codeCompleteGetContexts(QBCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetContexts(arg0);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Returns the cursor kind for the container for the current code completion context. The container is only guaranteed to be set for contexts where a container exists (i.e. member accesses or Objective-C message sends); if there is not a container, this function will return CXCursor_InvalidCode.
        ///</summary>
        public static CXCursorKind codeCompleteGetContainerKind(QBCodeCompleteResults[] Results, out uint IsIncomplete)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetContainerKind(arg0, out IsIncomplete);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Returns the USR for the container for the current code completion context. If there is not a container for the current context, this function will return the empty string.
        ///</summary>
        public static QBString codeCompleteGetContainerUSR(QBCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetContainerUSR(arg0);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Returns the currently-entered selector for an Objective-C message send, formatted like "initWithFoo:bar:". Only guaranteed to return a non-empty string for CXCompletionContext_ObjCInstanceMessage and CXCompletionContext_ObjCClassMessage.
        ///</summary>
        public static QBString codeCompleteGetObjCSelector(QBCodeCompleteResults[] Results)
        {
            QuantumBinding.Clang.Interop.CXCodeCompleteResults[] arg0 = null;
            arg0 = ReferenceEquals(Results, null) ? null : new QuantumBinding.Clang.Interop.CXCodeCompleteResults[Results.Length];
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    arg0[i] = Results[i].ToInternal();
                }
            }
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_codeCompleteGetObjCSelector(arg0);
            if (!ReferenceEquals(Results, null))
            {
                for (var i = 0U; i < Results.Length; ++i)
                {
                    Results[i]?.Dispose();
                }
            }
            return result;
        }

        ///<summary>
        /// Return a version string, suitable for showing to a user, but not intended to be parsed (the format is not guaranteed to be stable).
        ///</summary>
        public static QBString getClangVersion()
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getClangVersion();
        }

        ///<summary>
        /// Enable/disable crash recovery.
        ///</summary>
        public static void toggleCrashRecovery(uint isEnabled)
        {
            QuantumBinding.Clang.Interop.ClangInterop.clang_toggleCrashRecovery(isEnabled);
        }

        ///<summary>
        /// Retrieve a remapping.
        ///</summary>
        public static QBRemapping getRemappings(string path)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getRemappings(path);
        }

        ///<summary>
        /// Retrieve a remapping.
        ///</summary>
        public static QBRemapping getRemappingsFromFileList(in string[] filePaths, uint numFiles)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_getRemappingsFromFileList(filePaths, numFiles);
        }

        public static int index_isEntityObjCContainerKind(CXIdxEntityKind param0)
        {
            return QuantumBinding.Clang.Interop.ClangInterop.clang_index_isEntityObjCContainerKind(param0);
        }

        public static QBIdxObjCContainerDeclInfo index_getObjCContainerDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCContainerDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static QBIdxObjCInterfaceDeclInfo index_getObjCInterfaceDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCInterfaceDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static QBIdxObjCCategoryDeclInfo index_getObjCCategoryDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCCategoryDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static QBIdxObjCProtocolRefListInfo index_getObjCProtocolRefListInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCProtocolRefListInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static QBIdxObjCPropertyDeclInfo index_getObjCPropertyDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getObjCPropertyDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static QBIdxIBOutletCollectionAttrInfo index_getIBOutletCollectionAttrInfo(in QBIdxAttrInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getIBOutletCollectionAttrInfo(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        public static QBIdxCXXClassDeclInfo index_getCXXClassDeclInfo(in QBIdxDeclInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getCXXClassDeclInfo(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// For retrieving a custom CXIdxClientContainer attached to a container.
        ///</summary>
        public static QBIdxClientContainer index_getClientContainer(in QBIdxContainerInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getClientContainer(arg0);
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// For setting a custom CXIdxClientContainer attached to a container.
        ///</summary>
        public static void index_setClientContainer(in QBIdxContainerInfo param0, QuantumBinding.Clang.QBIdxClientContainer param1)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var arg1 = ReferenceEquals(param1, null) ? new CXIdxClientContainerImpl() : (CXIdxClientContainerImpl)param1;
            QuantumBinding.Clang.Interop.ClangInterop.clang_index_setClientContainer(arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        ///<summary>
        /// For retrieving a custom CXIdxClientEntity attached to an entity.
        ///</summary>
        public static QBIdxClientEntity index_getClientEntity(in QBIdxEntityInfo param0)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var result = QuantumBinding.Clang.Interop.ClangInterop.clang_index_getClientEntity(arg0);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
            return result;
        }

        ///<summary>
        /// For setting a custom CXIdxClientEntity attached to an entity.
        ///</summary>
        public static void index_setClientEntity(in QBIdxEntityInfo param0, QuantumBinding.Clang.QBIdxClientEntity param1)
        {
            var arg0 = ReferenceEquals(param0, null) ? System.IntPtr.Zero : MarshalUtils.MarshalStructToPtr(param0.ToInternal());
            var arg1 = ReferenceEquals(param1, null) ? new CXIdxClientEntityImpl() : (CXIdxClientEntityImpl)param1;
            QuantumBinding.Clang.Interop.ClangInterop.clang_index_setClientEntity(arg0, arg1);
            param0?.Dispose();
            Marshal.FreeHGlobal(arg0);
        }

    }

}

