using System;
using System.Collections.Generic;
using System.Linq;
using QuantumBinding.Generator.AST;
using Delegate = QuantumBinding.Generator.AST.Delegate;

namespace QuantumBinding.Generator.CodeGeneration
{
    public abstract class CodeGenerator : CodeBlockGenerator
    {
        // Extracted from:
        // https://github.com/mono/mono/blob/master/mcs/class/System/Microsoft.CSharp/CSharpCodeGenerator.cs
        public static readonly string[] ReservedWords =
        {
            "abstract", "event", "new", "struct", "as", "explicit", "null", "switch",
            "base", "extern", "this", "false", "operator", "throw", "break", "finally",
            "out", "true", "fixed", "override", "try", "case", "params", "typeof",
            "catch", "for", "private", "foreach", "protected", "checked", "goto",
            "public", "unchecked", "class", "if", "readonly", "unsafe", "const",
            "implicit", "ref", "continue", "in", "return", "using", "virtual", "default",
            "interface", "sealed", "volatile", "delegate", "internal", "do", "is",
            "sizeof", "while", "lock", "stackalloc", "else", "static", "enum",
            "namespace", "object", "bool", "byte", "float", "uint", "char", "ulong",
            "ushort", "decimal", "int", "sbyte", "short", "double", "long", "string",
            "void", "partial", "yield", "where"
        };

        protected CodeGenerator(ProcessingContext context, TranslationUnit unit, GeneratorCategory category) : 
            this(context, new List<TranslationUnit>() { unit }, category)
        {
        }

        protected CodeGenerator(ProcessingContext context, IEnumerable<TranslationUnit> units, GeneratorCategory category)
        {
            Name = string.Empty;
            Context = context;
            TranslationUnits = units.ToList();
            Category = category;
        }

        public bool IsEmpty { get; protected set; }

        public GeneratorCategory Category { get; }

        public string GeneratorName => "QuantumBindingGenerator";

        public abstract string GetFileName(TranslationUnit unit);
        
        public abstract string FolderName { get; }
        
        public ProcessingContext Context { get; }

        public BindingOptions Options => Context.Options;

        public ASTContext AstContext => Context.AstContext;

        public List<TranslationUnit> TranslationUnits { get; }
        
        public string Name { get; set; }

        public virtual bool IsInteropGenerator =>
            Category is
                GeneratorCategory.Structs or
                GeneratorCategory.Unions or 
                GeneratorCategory.Functions or 
                GeneratorCategory.Delegates;

        public abstract void Run();

        public abstract void Run(Declaration declaration);

        protected void GenerateFileHeader()
        {
            PushBlock(CodeBlockKind.Header);
            GenerateComment(CommentKind.CSharpShort);
            NewLine();
            PopBlock();
        }

        private void GenerateComment(CommentKind commentKind)
        {
            var header = AstContext.Module.FileHeader;

            PushBlock(CodeBlockKind.AutoGenerated);
            GenerateMultilineComment(header.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries), commentKind);
            PopBlock();
        }

        protected void GenerateSummary(string summary)
        {
            var lines = summary.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries);

            WriteLine("///<summary>");
            foreach (var line in lines)
            {
                WriteLine($"{GetMultilineCommentStart(CommentKind.CSharp)} {line}");
            }
            WriteLine("///</summary>");
        }

        public virtual void GenerateCommentIfNotEmpty(Comment comment)
        {
            if (comment != null && comment.Text != null)
            {
                PushBlock(CodeBlockKind.Comment);
                GenerateSummary(comment.BriefText);
                PopBlock();
            }
        }

        private void GenerateMultilineComment(IEnumerable<string> comment, CommentKind commentKind)
        {
            var commentStart = GetCommentLineStart(commentKind);
            if (!string.IsNullOrEmpty(commentStart))
            {
                Write(commentStart);
            }

            var multilineComment = GetMultilineCommentStart(commentKind);
            foreach (var line in comment)
            {
                WriteLine($"{multilineComment} {line.Trim()}");
            }

            var commentEnd = GetCommentLineEnd(commentKind);
            if (!string.IsNullOrEmpty(commentEnd))
            {
                WriteLine(commentEnd);
            }
        }

        private string GetCommentLineStart(CommentKind kind)
        {
            switch (kind)
            {
                case CommentKind.CSharp:
                case CommentKind.CSharpShort:
                    return "";
                default:
                    return "/*";
            }
        }

        private string GetMultilineCommentStart(CommentKind kind)
        {
            switch (kind)
            {
                case CommentKind.CSharp:
                    return "///";
                case CommentKind.CSharpShort:
                    return "//";
                default:
                    return "*";
            }
        }

        private string GetCommentLineEnd(CommentKind kind)
        {
            switch (kind)
            {
                case CommentKind.CSharp:
                case CommentKind.CSharpShort:
                    return string.Empty;
                default:
                    return "*/";
            }
        }

        protected virtual void GenerateMacro(Macro macro) {}

        protected virtual void GenerateEnum(Enumeration @enum) {}

        protected virtual void GenerateClass(Class @class) {}

        protected virtual void GenerateDelegate(Delegate @delegate) { }

        protected virtual void GenerateFunction(Function function) {}
    }
}